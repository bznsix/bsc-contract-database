{"Context.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"},"IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller\u0027s account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"},"Ownable.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"},"Staking.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.4;\r\n\r\nimport \"./IERC20.sol\";\r\nimport \"./Ownable.sol\";\r\n\r\ncontract Staking is Ownable {\r\n    uint256 internal constant DISTRIBUTION_MULTIPLIER = 2**64;\r\n\r\n    IERC20 public token;\r\n\r\n    mapping(address =\u003e uint256) public stakeValue;\r\n    mapping(address =\u003e uint256) public stakerPayouts;\r\n\r\n    uint256 public totalDistributions;\r\n    uint256 public totalStaked;\r\n    uint256 public totalStakers;\r\n    uint256 public profitPerShare;\r\n    uint256 private emptyStakeTokens;\r\n\r\n    uint256 public startTime;\r\n\r\n    event OnStake(address sender, uint256 amount);\r\n    event OnUnstake(address sender, uint256 amount);\r\n    event OnWithdraw(address sender, uint256 amount);\r\n    event OnDistribute(address sender, uint256 amount);\r\n    event Received(address sender, uint256 amount);\r\n    event UpdateStartTime(uint256 timestamp);\r\n\r\n    constructor(IERC20 _token) {\r\n        token = _token;\r\n    }\r\n\r\n    modifier whenStakingActive {\r\n        require(\r\n            startTime != 0 \u0026\u0026 block.timestamp \u003e startTime,\r\n            \"Staking not yet started.\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    function setStartTime(uint256 _startTime) external onlyOwner {\r\n        require(startTime == 0 || block.timestamp \u003c startTime, \"Staking already active\");\r\n        startTime = _startTime;\r\n        emit UpdateStartTime(_startTime);\r\n    }\r\n\r\n    function dividendsOf(address staker) public view returns (uint256) {\r\n        uint256 divPayout = profitPerShare * stakeValue[staker];\r\n        require(divPayout \u003e= stakerPayouts[staker], \"dividend calc overflow\");\r\n\r\n        return (divPayout - stakerPayouts[staker]) / DISTRIBUTION_MULTIPLIER;\r\n    }\r\n\r\n    function stake(uint256 amount) public whenStakingActive {\r\n        require(\r\n            token.balanceOf(msg.sender) \u003e= amount,\r\n            \"Cannot stake more SLF than you hold unstaked.\"\r\n        );\r\n        if (stakeValue[msg.sender] == 0) totalStakers += 1;\r\n\r\n        _addStake(amount);\r\n\r\n        require(\r\n            token.transferFrom(msg.sender, address(this), amount),\r\n            \"Stake failed due to failed transfer.\"\r\n        );\r\n\r\n        emit OnStake(msg.sender, amount);\r\n    }\r\n\r\n    function unstake(uint256 amount) external whenStakingActive {\r\n        require(\r\n            stakeValue[msg.sender] \u003e= amount,\r\n            \"Cannot unstake more SLF than you have staked.\"\r\n        );\r\n\r\n        withdraw(dividendsOf(msg.sender));\r\n\r\n        if (stakeValue[msg.sender] == amount) totalStakers = totalStakers -= 1;\r\n\r\n        totalStaked = totalStaked -= amount;\r\n        stakeValue[msg.sender] = stakeValue[msg.sender] -= amount;\r\n        stakerPayouts[msg.sender] = profitPerShare * stakeValue[msg.sender];\r\n\r\n        token.approve(address(this), amount);\r\n\r\n        require(\r\n            token.transferFrom(address(this), msg.sender, amount),\r\n            \"Unstake failed due to failed transfer.\"\r\n        );\r\n\r\n        emit OnUnstake(msg.sender, amount);\r\n    }\r\n\r\n    function withdraw(uint256 amount) public payable whenStakingActive {\r\n        require(\r\n            dividendsOf(msg.sender) \u003e= amount,\r\n            \"Cannot withdraw more dividends than you have earned.\"\r\n        );\r\n\r\n        stakerPayouts[msg.sender] =\r\n            stakerPayouts[msg.sender] +\r\n            amount *\r\n            DISTRIBUTION_MULTIPLIER;\r\n        payable(msg.sender).transfer(amount);\r\n        emit OnWithdraw(msg.sender, amount);\r\n    }\r\n\r\n    function distribute() external payable {\r\n        // Forward 10% to dev wallet\r\n        uint256 split = (msg.value * 10) / 100;\r\n        uint256 amount = msg.value - split;\r\n\r\n        payable(owner()).transfer(split);\r\n\r\n        if (amount \u003e 0) {\r\n            totalDistributions += amount;\r\n            _increaseProfitPerShare(amount);\r\n            emit OnDistribute(msg.sender, amount);\r\n        }\r\n    }\r\n\r\n    function _addStake(uint256 _amount) internal {\r\n        totalStaked += _amount;\r\n        stakeValue[msg.sender] += _amount;\r\n\r\n        uint256 payout = profitPerShare * _amount;\r\n        stakerPayouts[msg.sender] = stakerPayouts[msg.sender] + payout;\r\n    }\r\n\r\n    function _increaseProfitPerShare(uint256 amount) internal {\r\n        if (totalStaked != 0) {\r\n            if (emptyStakeTokens != 0) {\r\n                amount += emptyStakeTokens;\r\n                emptyStakeTokens = 0;\r\n            }\r\n            profitPerShare += ((amount * DISTRIBUTION_MULTIPLIER) / totalStaked);\r\n        } else {\r\n            emptyStakeTokens += amount;\r\n        }\r\n    }\r\n\r\n    receive() external payable {\r\n        emit Received(msg.sender, msg.value);\r\n    }\r\n}\r\n"}}