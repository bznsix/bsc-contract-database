{"IERC20.sol":{"content":"pragma solidity ^0.5.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see `ERC20Detailed`.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller\u0027s account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\n     * zero by default.\n     *\n     * This value changes when `approve` or `transferFrom` are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * \u003e Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an `Approval` event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to `approve`. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"},"IIncentiveModelSimple.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.5.16;\n//pragma experimental ABIEncoderV2;\n\n\nimport \"./IERC20.sol\";\n\n\ninterface IIncentiveModelSimple {\n\n    /**\n     * @notice For Lens\n     */\n    function protocolFeeTrade() external view returns(uint);\n\n    function protocolFeeDeposit() external view returns(uint);\n\n    function protocolFeeRedeem() external view returns(uint);\n\n    function isIncentiveModel() external view returns(bool);\n    function totalDepositFee(IERC20 _depositBEP20, uint _valueDeposit, int priorDelta, int postDelta, uint price, uint balanceXTT)  external view returns(int totalFee, uint protocolFeePerc, uint reward, uint fee);\n    function totalRedeemFee(IERC20 _redeemBep20, uint _valueRedeem, int priorDelta, int postDelta, uint price, uint balanceXTT) external view returns(int totalFee, uint protocolFeePerc, uint reward, uint fee);\n    function valueOutAfterSell(IERC20 _tokenIn, uint _valueIn, int priorDeltaIn, int postDeltaIn, uint balanceXTT) external view returns(uint redeemValue);\n    function valueOutAfterBuy(IERC20 _tokenOut, uint _valueAfterSell, int priorDeltaOut, int postDeltaOut) external view returns(uint buyValue);\n\n}"},"IncentiveModelSimple.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.5.16;\n//pragma experimental ABIEncoderV2;\n\nimport \"./IIncentiveModelSimple.sol\";\nimport \"./Lib.sol\";\nimport \"./SignedSafeMath.sol\";\nimport \"./SafeMath.sol\";\n\n// Add to Github Repo\n// 1) Create updatable feePerToken() underlying:fee pairs, similar to CompTT (make sure cant duplicate underlying)\n//      - add array of underlying\n// 2) Upgradeable protocolFeeDeposit, protocolFeeRedeem, protocolFeeTrade\n//      - keep discount and threshold fixed \n\ncontract IncentiveModelSimple is IIncentiveModelSimple {\n\n    using SignedSafeMath for int;\n    using SafeMath for uint;\n\n    // ---------- PUBLIC VARIABLES ------------- // \n\n    /**\n     * @notice Used as a sanity check when adding incentive model to Trend Token\n     */\n    bool public constant isIncentiveModel = true;\n\n    /**\n     * @notice Has permission to make changes\n     */\n    address public admin;\n\n    /**\n     *@notice Base fee charged when depositing for Trend Tokens\n     */\n    uint public protocolFeeDeposit = 0.0015e18;\n\n    /**\n     *@notice Base fee charged when redeeming Trend Tokens for underlying\n     */\n    uint public protocolFeeRedeem = 0.0025e18;\n\n    /**\n     *@notice Base fee charged when trading underlying for underlying\n     */\n    uint public protocolFeeTrade = 0.0015e18;\n    \n\n    /**\n     * @notice Discounts when meeting low, med, and high XTT Thresholds\n     */\n    uint public lowDiscount = 0.20e18;\n    uint public medDiscount = 0.40e18;\n    uint public highDiscount = 0.80e18;\n\n    /**\n     * @notice Amount of XTT required to be held to receive low, med, and high discounts\n     */\n    uint public lowThreshold = 100e18;\n    uint public medThreshold = 10000e18;\n    uint public highThreshold = 100000e18;\n\n\n    /**\n     * @notice Maps ERC20 token to its base reward/fee when depositing or redeeming\n     * @dev If BNB: 0.50%, then 0.50% reward when depositing BNB if protocol desires more\n     *                          0.50% fee when redeeming BNB if protocol desires less\n     */\n    mapping(address =\u003e uint) public feePerToken;\n\n\n    /**\n     * @notice Maintains a list of all underlying assets that are included in the feePerToken mapping\n     *         This allows this underlying to be deposited, redeemed, or traded\n     */\n    IERC20[] public allUnderlying;\n\n\n    /**\n     * @notice Emitted when updated associated values\n     */\n    event UpdateFeeDiscount(uint oldLow, uint oldMed, uint oldHigh, uint newLow, uint newMed, uint newHigh);\n    event UpdateDepositFee(uint oldFee, uint newFee);\n    event UpdateRedeemFee(uint oldFee, uint newFee);\n    event UpdateProtocolFee(uint oldFee, uint newFee);\n\n\n\n    constructor() public {\n        admin = msg.sender;\n    }\n\n    \n    /**\n     *  Changes the XTT holding threshold for 20%, 40%, and 60% trading fees on buying/selling Trend Tokens\n     */\n    function _updateTradeFeeDiscounts(uint _lowThres, uint _medThres, uint _highThres) external {\n        require(msg.sender == admin,\"!admin\");\n        require(_lowThres \u003c _medThres \u0026\u0026 _medThres \u003c _highThres \u0026\u0026 _highThres \u003c= 1e18,\"!threshold\");\n        uint oldLow = lowThreshold;\n        uint oldMed = medThreshold;\n        uint oldHigh = highThreshold;\n        lowThreshold = _lowThres;\n        medThreshold = _medThres;\n        highThreshold = _highThres;\n        emit UpdateFeeDiscount(oldLow, oldMed, oldHigh, lowThreshold, medThreshold, highThreshold);\n    }\n\n\n    /**\n     * @notice Updates deposit fee when buying Trend Tokens\n     */\n    function _updateDepositFee(uint _newDepositFee) external {\n        require(msg.sender == admin,\"!admin\");\n        require(_newDepositFee \u003c= 0.05e18,\"max 5%\");\n        uint oldFee = protocolFeeDeposit;\n        protocolFeeDeposit = _newDepositFee;\n        emit UpdateDepositFee(oldFee, protocolFeeDeposit);\n    }\n\n\n    /**\n     * @notice Updates redeem fee when selling Trend Tokens\n     */\n    function _updateRedeemFee(uint _newRedeemFee) external {\n        require(msg.sender == admin,\"!admin\");\n        require(_newRedeemFee \u003c= 0.10e18,\"max 10%\");\n        uint oldFee = protocolFeeRedeem;\n        protocolFeeRedeem = _newRedeemFee;\n        emit UpdateRedeemFee(oldFee, protocolFeeRedeem);\n    }\n\n\n    /**\n     * @notice Updates redeem fee when trading underlying for underlying\n     */\n    function _updateProtocolFeeTrade(uint _newProtocolFee) external {\n        require(msg.sender == admin,\"!admin\");\n        require(_newProtocolFee \u003c= 0.050e18,\"max 5%\");\n        uint oldFee = protocolFeeTrade;\n        protocolFeeTrade = _newProtocolFee;\n        emit UpdateProtocolFee(oldFee, protocolFeeTrade);\n    }\n\n\n    /**\n     * @notice Returns the trade fee discount for holding XDP tokens\n     * @param _traderBalance The traders balance of XDP tokens\n     */\n    function feeDiscount(uint _traderBalance) public view returns(uint discount) {\n        if (_traderBalance \u003e= highThreshold) {\n            discount = highDiscount;\n        } else if (_traderBalance \u003e= medThreshold) {\n            discount = medDiscount;\n        } else if (_traderBalance \u003e= lowThreshold) {\n            discount = lowDiscount;\n        } else {\n            discount = 0;\n        }\n    }\n\n\n    /**\n     * @notice Allows admin to change the fee/reward for deposit, redeem, and trade for each token\n     * @ testnet\n     * BNB: 0xae13d989daC2f0dEbFf460aC112a837C89BAa7cd ==\u003e 2000000000000000\n     * BUSD: 0x8301F2213c0eeD49a7E28Ae4c3e91722919B8B47 ==\u003e 2500000000000000\n     * BTC: 0xA808e341e8e723DC6BA0Bb5204Bafc2330d7B8e4 ==\u003e 3000000000000000\n     */\n    function _updateFeePerToken(IERC20 underlying, uint feeOrReward) external {\n        require(msg.sender == admin,\"!admin\");\n        require(feeOrReward \u003e 0 \u0026\u0026 feeOrReward \u003c= 0.05e18,\"max 5%, min\u003e0\");\n        if (feePerToken[address(underlying)] == 0) {\n            allUnderlying.push(underlying);\n        }\n        feePerToken[address(underlying)] = feeOrReward;\n    }\n\n\n    /**\n     * @notice Returns the fee/reward for specified underlying token\n     * @dev If fee/reward is zero, then it wasnt updated, and default fee 5%\n     */\n    function returnFeePerToken(IERC20 underlying) internal view returns(uint) {\n        uint fee = feePerToken[address(underlying)];\n        require(fee\u003e0,\"feePerToken not updated.\");\n        return fee;\n    }\n\n    function returnFeePerTokenExt(IERC20 underlying) external view returns(uint) {\n        return returnFeePerToken(underlying);\n    }\n\n    // ------------- CALCULATING DEPOSIT/REDEEM FEE OR REWARD ---------------- //\n\n\n    /**\n     * @notice calculates the reward (or fee) when user deposits a token\n     * @param _bep20 The underlying asset to be deposited\n     * @param _valueIn The value of deposited _bep20 (un-used for now)\n     * @param _priorDelta Desired allocations minus actual allocations before _bep20 deposit (positive if desired more asset) \n     * @param _postDelta Desired allocations minus estimated allocations after _bep20 deposit\n     */\n    function depositRewardOrFee(IERC20 _bep20, uint _valueIn, int _priorDelta, int _postDelta) internal view returns(uint reward, uint fee) {\n\n        _valueIn; // may be used in the future to vary deposit reward (or fee)\n\n        if (_priorDelta \u003e= 0) { // require more of the token (net reward unless far excess) \n\n            uint priorDelta = uint(_priorDelta);\n            reward = returnFeePerToken(_bep20);\n\n            if (_postDelta \u003c 0) { // all deposit goes towards desired\n\n                uint excess = uint(-_postDelta);\n\n                if (priorDelta \u003e= excess) { // most of the deposit goes towards desired (net reward) \n\n                    uint rewardFactor = Lib.getAssetAmt(uint(priorDelta.sub(excess)),priorDelta);\n                    reward = Lib.getValue(reward, rewardFactor);\n\n                } else {\n\n                    uint feeFactor = Lib.getAssetAmt(uint(excess.sub(priorDelta)),excess);\n                    fee = Lib.getValue(feeFactor,reward);\n                    reward = 0;\n\n                }\n\n            }\n\n        } else { // desires less of the token (full fee)\n\n            fee = returnFeePerToken(_bep20);\n\n        }\n\n\n    }\n\n\n    function redeemRewardOrFee(IERC20 _bep20, uint _valueIn, int _priorDelta, int _postDelta) internal view returns(uint reward, uint fee) {\n\n        _valueIn; // may be used in the future to vary deposit reward (or fee)\n        \n        if (_priorDelta \u003c= 0) { // require less of the token (net reward unless far excess) \n\n            reward = returnFeePerToken(_bep20);\n\n            if (_postDelta \u003e 0) { // all deposit goes towards desired\n\n                uint priorDelta = uint(-_priorDelta);\n                uint excess = uint(_postDelta);\n\n                if (priorDelta \u003e= excess) { // most of the deposit goes towards desired (net reward) \n\n                    uint rewardFactor = Lib.getAssetAmt(uint(priorDelta.sub(excess)),priorDelta);\n                    reward = Lib.getValue(reward, rewardFactor);\n\n                } else {\n\n                    uint feeFactor = Lib.getAssetAmt(uint(excess.sub(priorDelta)),excess);\n                    fee = Lib.getValue(feeFactor,reward);\n                    reward = 0;\n\n                }\n\n            }\n\n        } else { // desires less of the token (full fee)\n\n            fee = returnFeePerToken(_bep20);\n\n        }\n\n\n    }\n\n\n\n    /** \n     * @notice Caculates the trade fee (reward) perfect for specified trade\n     * @dev Only considers the amount needed to be traded to get within threshold\n     * param _valueIn The USD value being deposited by user\n     * param _tokenEquity The contract plus collateral values of token being deposited\n     * param _poolEquity The total equity in the pool\n     * param _allocationDelta Desired allocation (percent) minus current allocation (percent)\n     *                         Positive if Trend Token wants more of the asset\n     * @return reward if deposit/withdrawal rebalances productively, fee if counterproductively\n     * re-arrange this to have valueFor and valueAgainst\n     */\n\n\n    /** \n     * @notice Returns the total Trend Token deposit fee \n     * @dev May be negative if reward exceeds the protocolBaseFee (especially if high XDP discount)\n     * @param reward The incentive reward if any\n     * @param fee The incentive fee if any\n     */\n    function totalDepositFee(IERC20 _depositBEP20, uint _valueDeposit, int priorDelta, int postDelta, uint price, uint balanceXTT)  \n             external view returns(int totalFee, uint protocolFeePerc, uint reward, uint fee) {\n        price; // may be used in the future\n        (reward, fee) = depositRewardOrFee(_depositBEP20,_valueDeposit, priorDelta, postDelta);\n        uint feeFactorFromDiscountXTT = uint(1e18).sub(feeDiscount(balanceXTT));\n        protocolFeePerc = protocolFeeDeposit.mul(feeFactorFromDiscountXTT).div(1e18);\n        totalFee = int(protocolFeePerc).add(int(fee)).sub(int(reward));\n        return (totalFee, protocolFeePerc, reward, fee);\n\n    }\n\n\n    /** \n     * @notice Returns the total Trend Token redeem fee \n     * @dev May be negative if reward exceeds the protocolBaseFee (especially if high XDP discount)\n     * @param reward The incentive reward if any\n     * @param fee The incentive fee if any\n     */\n    function totalRedeemFee(IERC20 _redeemBep20, uint _valueRedeem, int priorDelta, int postDelta, uint price, uint balanceXTT) \n             external view returns(int totalFee, uint protocolFeePerc, uint reward, uint fee) {\n        price; // may be used in the future\n        (reward, fee) = redeemRewardOrFee(_redeemBep20,_valueRedeem, priorDelta, postDelta);\n        uint feeFactorFromDiscountXTT = uint(1e18).sub(feeDiscount(balanceXTT));\n        protocolFeePerc = protocolFeeRedeem.mul(feeFactorFromDiscountXTT).div(1e18);\n        totalFee = int(protocolFeePerc).add(int(fee)).sub(int(reward));\n        return (totalFee, protocolFeePerc, reward, fee);\n\n    }\n\n    // ------------- TRADE FUNCTIONS ----------------- // \n\n\n    /**\n     * @notice Returns the value out after _tokenIn is sold\n     */\n    function valueOutAfterSell(IERC20 _tokenIn, uint _valueIn, int priorDeltaIn, int postDeltaIn, uint balanceXTT) external view returns(uint redeemValue) {\n        (uint rewardIn, uint feeIn) = depositRewardOrFee(_tokenIn,_valueIn, priorDeltaIn, postDeltaIn);\n        uint feeFactorFromDiscountXTT = uint(1e18).sub(feeDiscount(balanceXTT));\n        uint protocolFeePerc = protocolFeeTrade.mul(feeFactorFromDiscountXTT).div(1e18);\n        int totalFeeIn = int(protocolFeePerc).add(int(feeIn)).sub(int(rewardIn));\n        uint muliple = uint(int(1e18).sub(totalFeeIn));\n        redeemValue = _valueIn.mul(muliple).div(1e18);\n    }\n\n\n    function valueOutAfterBuy(IERC20 _tokenOut, uint _valueAfterSell, int priorDeltaOut, int postDeltaOut) external view returns(uint buyValue)  {\n        // calculates value out\n        (uint rewardOut, uint feeOut) = redeemRewardOrFee(_tokenOut,_valueAfterSell, priorDeltaOut, postDeltaOut);\n        uint multiple = uint(int(1e18).sub(int(feeOut).sub(int(rewardOut))));\n        buyValue = _valueAfterSell.mul(multiple).div(1e18);\n\n    }\n\n\n}\n"},"Lib.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.5.16;\n\nimport \"./SafeMath.sol\";\nimport \"./SignedSafeMath.sol\";\n\n\nlibrary Lib { // deployed at: 0x92EB22eb4f4dFE719a988F328cE88ce36DD5279A\n\n    using SafeMath for uint;\n    using SignedSafeMath for int;\n\n    // Contastants \n    uint public constant PRICE_DEN = 1e18;\n\n    // -----   PancakeSwap ----------- //\n\n    \n    function pathGenerator2(address coinIn, address coinOut) internal pure returns(address[] memory) {\n        address[] memory path = new address[](2);\n        path[0] = address(coinIn);\n        path[1] = address(coinOut);\n        return path;\n    }\n\n\n    function getValue(uint256 _amount, uint256 _price) internal pure returns(uint256) {\n        return _amount.mul(_price).div(PRICE_DEN);\n    }\n\n\n    function getAssetAmt(uint256 _usdAmount, uint256 _price) internal pure returns(uint256) {\n        return _usdAmount.mul(PRICE_DEN).div(_price);\n    }\n\n\n}"},"SafeMath.sol":{"content":"// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.5.16;\n\n// Copyright 2020 Venus Labs, Inc.\n\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n// 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A \n// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, \n// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, \n// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n\n/**\n * @dev Wrappers over Solidity\u0027s arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it\u0027s recommended to use it always.\n */\nlibrary SafeMath {\n  /**\n   * @dev Returns the addition of two unsigned integers, reverting on\n   * overflow.\n   *\n   * Counterpart to Solidity\u0027s `+` operator.\n   *\n   * Requirements:\n   * - Addition cannot overflow.\n   */\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    return add(a, b, \"SafeMath: addition overflow\");\n  }\n\n  /**\n   * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n   * overflow (when the result is negative).\n   *\n   * Counterpart to Solidity\u0027s `-` operator.\n   *\n   * Requirements:\n   * - Subtraction cannot overflow.\n   */\n  function add(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c \u003e= a, errorMessage);\n\n    return c;\n  }\n\n  /**\n   * @dev Returns the subtraction of two unsigned integers, reverting on\n   * overflow (when the result is negative).\n   *\n   * Counterpart to Solidity\u0027s `-` operator.\n   *\n   * Requirements:\n   * - Subtraction cannot overflow.\n   */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    return sub(a, b, \"SafeMath: subtraction overflow\");\n  }\n\n  //function Asub(uint256 a, uint256 b) public pure returns (uint256) {\n  //  return sub(a, b, \"SafeMath: subtraction overflow\");\n  //}\n\n  /**\n   * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n   * overflow (when the result is negative).\n   *\n   * Counterpart to Solidity\u0027s `-` operator.\n   *\n   * Requirements:\n   * - Subtraction cannot overflow.\n   */\n  function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n    require(b \u003c= a, errorMessage);\n    uint256 c = a - b;\n\n    return c;\n  }\n\n  /**\n   * @dev Returns the multiplication of two unsigned integers, reverting on\n   * overflow.\n   *\n   * Counterpart to Solidity\u0027s `*` operator.\n   *\n   * Requirements:\n   * - Multiplication cannot overflow.\n   */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\n    // benefit is lost if \u0027b\u0027 is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n    if (a == 0) {\n      return 0;\n    }\n\n    uint256 c = a * b;\n    require(c / a == b, \"SafeMath: multiplication overflow\");\n\n    return c;\n  }\n\n  /**\n   * @dev Returns the integer division of two unsigned integers. Reverts on\n   * division by zero. The result is rounded towards zero.\n   *\n   * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\n   * uses an invalid opcode to revert (consuming all remaining gas).\n   *\n   * Requirements:\n   * - The divisor cannot be zero.\n   */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    return div(a, b, \"SafeMath: division by zero\");\n  }\n\n  /**\n   * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n   * division by zero. The result is rounded towards zero.\n   *\n   * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\n   * uses an invalid opcode to revert (consuming all remaining gas).\n   *\n   * Requirements:\n   * - The divisor cannot be zero.\n   */\n  function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n    // Solidity only automatically asserts when dividing by 0\n    require(b \u003e 0, errorMessage);\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\n\n    return c;\n  }\n\n  /**\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n   * Reverts when dividing by zero.\n   *\n   * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\n   * invalid opcode to revert (consuming all remaining gas).\n   *\n   * Requirements:\n   * - The divisor cannot be zero.\n   */\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n    return mod(a, b, \"SafeMath: modulo by zero\");\n  }\n\n  /**\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n   * Reverts with custom message when dividing by zero.\n   *\n   * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\n   * invalid opcode to revert (consuming all remaining gas).\n   *\n   * Requirements:\n   * - The divisor cannot be zero.\n   */\n  function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n    require(b != 0, errorMessage);\n    return a % b;\n  }\n}"},"SignedSafeMath.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.5.16;\n\n\n/**\n * @title SignedSafeMath\n * @dev Signed math operations with safety checks that revert on error.\n */\nlibrary SignedSafeMath {\n    int256 constant private _INT256_MIN = -2**255;\n\n    /**\n     * @dev Multiplies two signed integers, reverts on overflow.\n     */\n    function mul(int256 a, int256 b) internal pure returns (int256) {\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\n        // benefit is lost if \u0027b\u0027 is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        require(!(a == -1 \u0026\u0026 b == _INT256_MIN), \"SignedSafeMath: multiplication overflow\");\n\n        int256 c = a * b;\n        require(c / a == b, \"SignedSafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Integer division of two signed integers truncating the quotient, reverts on division by zero.\n     */\n    function div(int256 a, int256 b) internal pure returns (int256) {\n        require(b != 0, \"SignedSafeMath: division by zero\");\n        require(!(b == -1 \u0026\u0026 a == _INT256_MIN), \"SignedSafeMath: division overflow\");\n\n        int256 c = a / b;\n\n        return c;\n    }\n\n    /**\n     * @dev Subtracts two signed integers, reverts on overflow.\n     */\n    function sub(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a - b;\n        require((b \u003e= 0 \u0026\u0026 c \u003c= a) || (b \u003c 0 \u0026\u0026 c \u003e a), \"SignedSafeMath: subtraction overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Adds two signed integers, reverts on overflow.\n     */\n    function add(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a + b;\n        require((b \u003e= 0 \u0026\u0026 c \u003e= a) || (b \u003c 0 \u0026\u0026 c \u003c a), \"SignedSafeMath: addition overflow\");\n\n        return c;\n    }\n}"}}