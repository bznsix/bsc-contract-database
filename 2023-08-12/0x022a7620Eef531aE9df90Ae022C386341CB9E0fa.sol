{"ERC20.sol":{"content":"// SPDX-License-Identifier: I-I-N-N-N-N-NFINITYYY!!\r\npragma solidity ^0.7.6;\r\n\r\nimport \"./SafeSubtraction.sol\";\r\nimport \"./IERC20.sol\"; \r\n\r\nabstract contract ERC20 is IERC20 {\r\n\r\n    using SafeSubtraction for uint256;\r\n\r\n    mapping (address =\u003e uint256) internal _balanceOf;\r\n    mapping (address =\u003e mapping (address =\u003e uint256)) public override allowance; \r\n\r\n    uint256 public override totalSupply;\r\n\r\n    string public override name = \"OctaDahlia\";\r\n    string public override symbol = \"OcDa\";\r\n    uint8 public override decimals = 18;\r\n\r\n    function balanceOf(address account) public virtual override view returns (uint256) { return _balanceOf[account]; }\r\n\r\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(msg.sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        _approve(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        uint256 oldAllowance = allowance[sender][msg.sender];\r\n        if (oldAllowance != uint256(-1)) {\r\n            _approve(sender, msg.sender, oldAllowance.sub(amount, \"ERC20: allow\"));\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\r\n        _balanceOf[sender] = _balanceOf[sender].sub(amount, \"ERC20: low balance\");\r\n        _balanceOf[recipient] += amount;\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        totalSupply += amount;\r\n        _balanceOf[account] += amount;\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        _balanceOf[account] = _balanceOf[account].sub(amount, \"ERC20: burn too much\");\r\n        totalSupply -= amount;\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\r\n        allowance[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    function burn(uint256 tokenAmounts) public virtual override {\r\n        _burn(msg.sender, tokenAmounts); \r\n    }\r\n\r\n}"},"IERC20.sol":{"content":"// SPDX-License-Identifier: I-N-N-N-N-NFINITYYY!!\r\npragma solidity ^0.7.6;\r\n\r\ninterface IERC20  {\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n    function burn(uint256 amount)external;\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address _account) external view returns (uint256);\r\n    function transfer(address _recipient, uint256 _amount) external returns (bool);\r\n    function allowance(address _owner, address _spender) external view returns (uint256);\r\n    function approve(address _spender, uint256 _amount) external returns (bool);\r\n    function transferFrom(address _sender, address _recipient, uint256 _amount) external returns (bool);\r\n\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n}"},"IFlowerFeeSplitter.sol":{"content":"// SPDX-License-Identifier: I-N-N-N-N-NFINITYYY!!\r\npragma solidity ^0.7.6;\r\n\r\ninterface IFlowerFeeSplitter {\r\n    function registerFlower(address flower, address pairedToken) external;\r\n    function depositFees(address flower, uint256 amount) external;\r\n    function payFees(address flower) external;    \r\n}"},"IMultiOwned.sol":{"content":"// SPDX-License-Identifier: I-N-N-N-N-NFINITYYY!!\r\npragma solidity ^0.7.6;\r\n\r\nimport \"./IERC20.sol\";\r\n\r\ninterface IMultiOwned {\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    function setInitialOwners(address owner1, address owner2, address owner3) external;\r\n    function addExtraOwners(uint256 indexSpot, address newOwner) external;\r\n    function ownerCount() external view returns (uint256);\r\n    function owners(uint256) external view returns (address);\r\n    function ownerIndex(address) external view returns (uint256);\r\n    function transferOwnership(address newOwner) external;\r\n    function claimOwnership() external;\r\n    function isOwner(address owner) external view returns (bool);\r\n}"},"IOctaDahlia.sol":{"content":"// SPDX-License-Identifier: I-N-N-N-N-NFINITYYY!!\r\npragma solidity ^0.7.6;\r\n\r\nimport \"./IMultiOwned.sol\";\r\n\r\ninterface IOctaDahlia is IMultiOwned { \r\n    function alignPrices() external returns (uint256);\r\n    function balanceAdjustment(bool increase, uint256 _amount, address _account) external;\r\n}"},"ITimeRift.sol":{"content":"// SPDX-License-Identifier: I-I-N-N-N-N-NFINITYYY!!\r\npragma solidity ^0.7.6;\r\n\r\nimport \"./IERC20.sol\";\r\n\r\ninterface ITimeRift {\r\n    function OctaDahliaGrowsBrighter(IERC20 pairedToken, uint256 startingLiquidity, uint256 startingTokenSupply, bool dictate, uint256 burnRate, uint256 maxBuyPercent) external returns (address);\r\n}"},"IUniswapV2Factory.sol":{"content":"// SPDX-License-Identifier: I-N-N-N-NFINITY!!!\r\npragma solidity ^0.7.6;\r\n\r\ninterface IUniswapV2Factory {\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n}"},"IUniswapV2Pair.sol":{"content":"// SPDX-License-Identifier: I-N-N-N-NFINITY!!!\r\npragma solidity ^0.7.6;\r\n\r\ninterface IUniswapV2Pair {\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function mint(address to) external;\r\n    function sync() external;\r\n    function skim(address to) external;\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n    function balanceOf(address _account) external view returns (uint256);\r\n    function transfer(address _recipient, uint256 _amount) external returns (bool);\r\n    function approve(address _spender, uint256 _amount) external returns (bool);\r\n}"},"IUniswapV2Router01.sol":{"content":"// SPDX-License-Identifier: I-N-N-N-NFINITY!!!\r\npragma solidity ^0.7.6;\r\n\r\ninterface IUniswapV2Router01 {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline) external payable returns (uint[] memory amounts);\r\n}"},"IUniswapV2Router02.sol":{"content":"// SPDX-License-Identifier: I-I-N-N-N-N-NFINITYYY!!\r\npragma solidity ^0.7.6;\r\n\r\nimport \u0027./IUniswapV2Router01.sol\u0027;\r\n\r\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin, \r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}"},"IWETH.sol":{"content":"// SPDX-License-Identifier: I-N-N-N-N-NFINITYYY!!\r\npragma solidity ^0.7.6;\r\n\r\ninterface IWETH {    \r\n    function deposit() external payable;\r\n}"},"LiquidityLockedERC20.sol":{"content":"// SPDX-License-Identifier: U-U-U-UPPPPP!!!\r\npragma solidity ^0.7.4;\r\n\r\nimport \"./ERC20.sol\";\r\nimport \"./IUniswapV2Pair.sol\";\r\n\r\nabstract contract LiquidityLockedERC20 is ERC20 {\r\n    mapping (IUniswapV2Pair =\u003e bool) public liquidityPairLocked;\r\n\r\n\r\n    struct CallRecord {\r\n        address origin;\r\n        uint32 blockNumber;\r\n        bool transferFrom;\r\n    }\r\n\r\n    CallRecord balanceAllowed;\r\n\r\n    function balanceOf(address account) public override view returns (uint256) {\r\n        IUniswapV2Pair pair = IUniswapV2Pair(address(msg.sender));\r\n        if (liquidityPairLocked[pair]) {\r\n            CallRecord memory last = balanceAllowed;\r\n            require (last.origin == tx.origin \u0026\u0026 last.blockNumber == block.number, \"Liquidity is locked\");\r\n            if (last.transferFrom) {\r\n                (uint256 reserve0, uint256 reserve1,) = pair.getReserves();\r\n                IERC20 token0 = IERC20(pair.token0());\r\n                if (address(token0) == address(this)) {\r\n                    require (IERC20(pair.token1()).balanceOf(address(pair)) \u003c reserve1, \"Liquidity is locked\");\r\n                }\r\n                else {\r\n                    require (token0.balanceOf(address(pair)) \u003c reserve0, \"Liquidity is locked\"); \r\n                }\r\n            }\r\n        }\r\n        return super.balanceOf(account);\r\n    }\r\n\r\n    function allowBalance(bool _transferFrom) private {\r\n        CallRecord memory last = balanceAllowed;\r\n        CallRecord memory allow = CallRecord({ \r\n            origin: tx.origin,\r\n            blockNumber: uint32(block.number),\r\n            transferFrom: _transferFrom\r\n        });\r\n        require (last.origin != allow.origin || last.blockNumber != allow.blockNumber || last.transferFrom != allow.transferFrom, \"Liquidity is locked (Please try again next block)\");\r\n        balanceAllowed = allow;\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\r\n        if (liquidityPairLocked[IUniswapV2Pair(address(msg.sender))]) {\r\n            allowBalance(false);\r\n        }\r\n        else {\r\n            balanceAllowed = CallRecord({ origin: address(0), blockNumber: 0, transferFrom: false });\r\n        }\r\n        return super.transfer(recipient, amount);\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\r\n        if (liquidityPairLocked[IUniswapV2Pair(recipient)]) {\r\n            allowBalance(true);\r\n        }\r\n        else {\r\n            balanceAllowed = CallRecord({ origin: address(0), blockNumber: 0, transferFrom: false });\r\n        }\r\n        return super.transferFrom(sender, recipient, amount);\r\n    }\r\n}"},"MultiOwned.sol":{"content":"// SPDX-License-Identifier: I-N-N-N-NFINITY!!!\r\npragma solidity ^0.7.6;\r\n\r\nimport \"./IMultiOwned.sol\";\r\n\r\nabstract contract MultiOwned is IMultiOwned {\r\n    \r\n    uint256 public override ownerCount; // 3 to start, up to 6 more, 9 in total\r\n\r\n    mapping (uint256 =\u003e address) public override owners;\r\n    mapping (address =\u003e uint256) public override ownerIndex; \r\n    address public pendingOwner;\r\n    bool public dictator;\r\n\r\n    modifier ownerSOnly() {\r\n        require (ownerIndex[msg.sender] != 0, \"Owners only\");\r\n        _;\r\n    }\r\n\r\n    modifier ownerOnly() {\r\n        require (ownerIndex[msg.sender] == 1, \"Owner 1 only\");\r\n        _;\r\n    }\r\n\r\n    function isOwner(address owner) public virtual override view returns (bool){\r\n        return ownerIndex[owner] != 0;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual override ownerSOnly() {\r\n        uint256 index = ownerIndex[msg.sender];\r\n        if (index == 1) {\r\n            pendingOwner = newOwner;\r\n        }\r\n        else {\r\n            address oldOwner =  owners[index];\r\n            require (msg.sender == oldOwner);\r\n            ownerIndex[oldOwner] = 0;\r\n            require (ownerIndex[newOwner] == 0);\r\n            owners[index] = newOwner;\r\n            ownerIndex[newOwner] = index;\r\n            emit OwnershipTransferred(oldOwner, newOwner);\r\n        }\r\n    }\r\n\r\n    function claimOwnership() public virtual override {\r\n        require (pendingOwner == msg.sender);\r\n        address oldOwner =  owners[1];\r\n        ownerIndex[oldOwner] = 0;\r\n        ownerIndex[msg.sender] = 1;\r\n        pendingOwner = address(0);\r\n        emit OwnershipTransferred(oldOwner, msg.sender);\r\n        owners[1] = msg.sender;\r\n    }\r\n\r\n    function setInitialOwners(address owner1, address owner2, address owner3) public virtual override {\r\n        require (ownerCount == 0);\r\n        owners[1] = owner1;\r\n         ownerIndex[owner1] = 1;\r\n        owners[2] = owner2;\r\n         ownerIndex[owner2] = 2;\r\n        owners[3] = owner3;\r\n         ownerIndex[owner3] = 3;\r\n        ownerCount = 3;\r\n    }\r\n\r\n    function addExtraOwners(uint256 indexSpot, address newOwner) public virtual override ownerOnly(){\r\n        if (dictator == false) {\r\n            require (owners[indexSpot] == address(0));\r\n            ownerCount++;\r\n            require (ownerCount \u003c 9);\r\n            owners[indexSpot] = newOwner;\r\n            ownerIndex[newOwner] = indexSpot;\r\n            emit OwnershipTransferred(address(0), newOwner);\r\n        }\r\n        else {\r\n            address oldOwner =  owners[indexSpot];\r\n            ownerIndex[oldOwner] = 0;\r\n            require (ownerIndex[newOwner] == 0, \"1 owner slot per address\");\r\n            owners[indexSpot] = newOwner;\r\n            ownerIndex[newOwner] = indexSpot;\r\n            emit OwnershipTransferred(oldOwner, newOwner);\r\n        }\r\n    }\r\n}"},"OctaDahlia.sol":{"content":"// SPDX-License-Identifier: I-I-N-N-N-N-NFINITYYY!!\r\npragma solidity ^0.7.6;\r\n\r\nimport \"./SafeSubtraction.sol\";\r\nimport \"./MultiOwned.sol\";\r\nimport \"./LiquidityLockedERC20.sol\";\r\nimport \"./IERC20.sol\";\r\nimport \"./IUniswapV2Pair.sol\";\r\nimport \"./IOctaDahlia.sol\"; \r\n\r\ncontract OctaDahlia is LiquidityLockedERC20, MultiOwned, IOctaDahlia {\r\n\r\n    using SafeSubtraction for uint256;\r\n\r\n    IUniswapV2Pair public pair;\r\n    IERC20 public pairedToken;\r\n    address public rift;\r\n    address public mge;\r\n    bool private isToken0;\r\n\r\n    uint256 public burnRate;\r\n    uint256 public maxBuyPercent;\r\n\r\n    constructor() {\r\n        rift = msg.sender; // remove if not launched by the Time Rift Contract, gives mint power\r\n    }\r\n\r\n    function balanceAdjustment(bool increase, uint256 _amount, address _account) external override {\r\n        require (msg.sender == rift || msg.sender == mge);\r\n        if (increase) {\r\n            _mint(_account, _amount);\r\n        }\r\n        else {\r\n            _burn(_account, _amount);\r\n        }\r\n    }\r\n\r\n    function alignPrices() public virtual override returns (uint256){\r\n        require (msg.sender == rift || msg.sender == mge);\r\n        liquidityPairLocked[pair] = false;\r\n        uint256 pendingFees = _balanceOf[rift];\r\n\r\n        uint256 out1 = getAmountOut(pendingFees);\r\n        uint256 out0 = 0;\r\n\r\n        _burn(rift, pendingFees);\r\n        _mint(address(pair), pendingFees);\r\n        if (!isToken0) {\r\n            out0 = out1;\r\n            out1 = 0;\r\n        }\r\n        address to = mge == address(0) ? rift : mge;\r\n        pair.swap(out0, out1, to, new bytes(0));\r\n\r\n        uint256 pairBalance = _balanceOf[address(pair)];\r\n        uint256 neededInPool = totalSupply - pairBalance;\r\n        if (neededInPool \u003e pairBalance) {\r\n            _mint(address(pair), neededInPool - pairBalance);\r\n        }\r\n        else if (pairBalance \u003e neededInPool){\r\n            _burn(address(pair), (pairBalance - neededInPool));\r\n        }\r\n        pair.sync();\r\n        liquidityPairLocked[pair] = true;\r\n        return isToken0 ? out1 : out0;\r\n    }\r\n \r\n    // set up functions\r\n    function setUp(IUniswapV2Pair _pair, address dev6, address dev9, address _mge, bool _dictator, uint256 _burnRate, uint256 _maxBuyPercent) external {\r\n        require (ownerCount == 0);\r\n        pair = _pair;\r\n        isToken0 = pair.token0() == address(this);\r\n        pairedToken = isToken0 ? IERC20(pair.token1()) : IERC20(pair.token0());\r\n        mge = _mge;\r\n        dictator = _dictator;\r\n        burnRate = _burnRate;\r\n        maxBuyPercent = _maxBuyPercent;\r\n        address owner1 = _mge == address(0) ? address(tx.origin) : _mge;\r\n        setInitialOwners(owner1, dev6, dev9);\r\n    }\r\n\r\n    function _transfer(address sender, address recipient, uint256 amount) internal override virtual {       \r\n        (uint256 dynamicBurnModifier, bool poolPriceHigher) = dynamicBurnRate();\r\n        bool buy = sender == address(pair);\r\n        bool sell = recipient == address(pair);\r\n\r\n        if (!buy \u0026\u0026 !sell) {\r\n            amount = _burnAndFees(sender, amount, burnRate);\r\n        }\r\n\r\n        if (sell) {\r\n            if (poolPriceHigher) {\r\n                amount = _burnAndFees(sender, amount, burnRate + dynamicBurnModifier);\r\n            }\r\n            else {\r\n                dynamicBurnModifier = dynamicBurnModifier + 100 \u003e burnRate ? 100 : burnRate - dynamicBurnModifier;\r\n                amount = _burnAndFees(sender, amount, dynamicBurnModifier);\r\n            }\r\n        }\r\n\r\n        _balanceOf[sender] = _balanceOf[sender].sub(amount, \"OcDa: low balance\");\r\n        _balanceOf[recipient] += amount;\r\n        emit Transfer(sender, recipient, amount);\r\n        \r\n        if (buy) {\r\n            require (amount \u003c totalSupply * maxBuyPercent / 10000);\r\n            if (poolPriceHigher) {\r\n                dynamicBurnModifier = dynamicBurnModifier + 100 \u003e burnRate ? 100 : burnRate - dynamicBurnModifier;\r\n                _burnAndFees(recipient, amount, dynamicBurnModifier);\r\n            }\r\n            else {\r\n                _burnAndFees(recipient, amount, burnRate + dynamicBurnModifier);\r\n            }\r\n        }       \r\n    }\r\n\r\n    function _burnAndFees(address account, uint256 amount, uint256 burnPercent) internal returns(uint256) {\r\n        uint256 burnAmount = amount * burnPercent / 10000;\r\n        uint256 fees = amount * 321 / 10000;\r\n        _balanceOf[account] = _balanceOf[account].sub(burnAmount + fees);\r\n        totalSupply -= burnAmount;\r\n        _balanceOf[rift] += fees;\r\n        emit Transfer(account, address(0), burnAmount);\r\n        emit Transfer(account, rift, fees);\r\n        return (amount - burnAmount - fees);\r\n    }\r\n\r\n    function dynamicBurnRate() internal view returns(uint256, bool) {\r\n        uint256 pairBalance = _balanceOf[address(pair)];\r\n        uint256 circSupply = totalSupply - pairBalance;\r\n        uint256 dif;\r\n        if (circSupply \u003e pairBalance) {\r\n            dif = circSupply - pairBalance;\r\n            return (dif * 9970 / circSupply, true);\r\n        }\r\n        else {\r\n            dif = pairBalance - circSupply;\r\n            return (dif * 9970 / circSupply, false);\r\n        }\r\n    }\r\n\r\n    function getAmountOut(uint amountIn) internal view returns (uint amountOut) {\r\n        uint amountInWithFee = amountIn * 997;\r\n        uint numerator = amountInWithFee * pairedToken.balanceOf(address(pair));\r\n        uint denominator = _balanceOf[address(pair)] * 1000 + amountInWithFee;\r\n        amountOut = numerator / denominator;\r\n    }\r\n\r\n    function recoverTokens(IERC20 token) public ownerSOnly() {\r\n        token.transfer(msg.sender, token.balanceOf(address(this)));\r\n    }\r\n}"},"SafeSubtraction.sol":{"content":"// SPDX-License-Identifier: I-I-N-N-N-N-NFINITYYY!!\r\npragma solidity ^0.7.6;\r\n\r\nlibrary SafeSubtraction {\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b \u003c= a, errorMessage);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n}"},"TimeRift.sol":{"content":"// SPDX-License-Identifier: I-I-N-N-N-N-NFINITYYY!!\r\npragma solidity ^0.7.6;\r\n\r\nimport \"./OctaDahlia.sol\";\r\nimport \"./ITimeRift.sol\";\r\nimport \"./IFlowerFeeSplitter.sol\";\r\nimport \"./IUniswapV2Factory.sol\";\r\n\r\ncontract TimeRift is MultiOwned, ITimeRift {\r\n\r\n    address private dev6;\r\n    address private dev9;\r\n    IUniswapV2Factory public uniswapFactory;\r\n    IFlowerFeeSplitter public splitter;\r\n    uint256 public dabPercent;\r\n\r\n    uint256 public lastNonce;\r\n    mapping (uint256 =\u003e OctaDahlia) public nonces; // nonce -\u003e flower\r\n    mapping (address =\u003e IUniswapV2Pair) public pools; // flower -\u003e pool\r\n    mapping (address =\u003e bool) public MGEs; // MGE Contract -\u003e y/n\r\n    mapping (address =\u003e bool) public balancers; // address that can call BalancePrices\r\n\r\n    event OctaDahliaCreated(address indexed flower, address paired, address pool);\r\n\r\n    constructor(address _dev6, address _dev9, IUniswapV2Factory _uniswapFactory) { \r\n        dev6 = _dev6;\r\n        dev9 = _dev9;\r\n        uniswapFactory = _uniswapFactory;\r\n        setInitialOwners(msg.sender, _dev6, _dev9);\r\n        dictator = true;\r\n    }\r\n\r\n    // Enable mint and burn for Market Generation Contracts that launch upOnly tokens\r\n    function enableMge(address _mge, bool _enable) public ownerSOnly() {\r\n        MGEs[_mge] = _enable;\r\n    }\r\n\r\n    function enableBalancer(address _balancer, bool _enable) public ownerSOnly() {\r\n        balancers[_balancer] = _enable;\r\n    }\r\n\r\n    function setFlowerFeeSplitter(IFlowerFeeSplitter _flowerFeeSplitter) public ownerSOnly() {\r\n        splitter = _flowerFeeSplitter;\r\n    }\r\n    \r\n    function setDabPercent(uint256 _dabPercent) public ownerSOnly() {\r\n        dabPercent = _dabPercent;\r\n    }\r\n\r\n    function OctaDahliaGrowsBrighter(IERC20 pairedToken, uint256 startingLiquidity, uint256 startingTokenSupply, bool dictate, uint256 burnRate, uint256 maxBuyPercent) public override ownerSOnly() returns (address) {\r\n        OctaDahlia Dahlia = new OctaDahlia();\r\n        lastNonce++;\r\n        nonces[lastNonce] = Dahlia;\r\n        IUniswapV2Pair pool = IUniswapV2Pair(uniswapFactory.createPair(address(Dahlia), address(pairedToken)));\r\n        pools[address(Dahlia)] = pool;\r\n        Dahlia.balanceAdjustment(true, startingTokenSupply, address(pool));\r\n        pairedToken.transferFrom(msg.sender, address(pool), startingLiquidity);\r\n        Dahlia.balanceAdjustment(true, startingTokenSupply, msg.sender);\r\n        pool.mint(address(this));\r\n        address mge = MGEs[msg.sender] ? msg.sender : address(0);\r\n        Dahlia.setUp(pool, dev6, dev9, mge, dictate, burnRate, maxBuyPercent);\r\n        splitter.registerFlower(address(Dahlia), address(pairedToken));\r\n        pairedToken.approve(address(splitter), uint(-1));\r\n        emit OctaDahliaCreated(address(Dahlia), address(pairedToken), address(pool));\r\n        return address(Dahlia);\r\n    }\r\n\r\n    function balancePrices(uint256[] memory noncesToBalance) public {\r\n        require (balancers[msg.sender] || MGEs[msg.sender]);\r\n        uint256 safeLength = noncesToBalance.length;\r\n        OctaDahlia Dahlia;\r\n        uint256 amount;\r\n        for (uint i = 0; i \u003c safeLength; i++) {\r\n            Dahlia = nonces[noncesToBalance[i]];\r\n            amount = Dahlia.alignPrices();\r\n            if (Dahlia.mge() == address(0)) {\r\n                splitter.depositFees(address(Dahlia), amount);\r\n            }\r\n        }\r\n    }\r\n\r\n    function whoNeedsBalance() public view returns (uint256[] memory) {\r\n        uint256[] memory toBalance = new uint256[](lastNonce);\r\n        OctaDahlia dahlia;\r\n        uint256 poolBalance;\r\n        uint256 trueSupply;\r\n        uint256 dif;\r\n        uint256 count = 0;\r\n        for (uint256 i = 1; i \u003c= lastNonce; i++) {\r\n            dahlia = nonces[i];\r\n            poolBalance = dahlia.balanceOf(address(pools[address(dahlia)]));\r\n            trueSupply = dahlia.totalSupply() - poolBalance;\r\n            dif = trueSupply \u003e poolBalance ? trueSupply - poolBalance : poolBalance - trueSupply;\r\n            if (dif * 9970 / trueSupply \u003e dabPercent) {\r\n                toBalance[count++] = i;\r\n            }\r\n        }\r\n        return toBalance;\r\n    }\r\n\r\n    function recoverTokens(IERC20 token) public ownerSOnly() {\r\n        token.transfer(msg.sender, token.balanceOf(address(this)));\r\n    }\r\n}"}}