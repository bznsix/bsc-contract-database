pragma solidity >=0.7.0 <0.9.0;
// SPDX-License-Identifier: MIT

/**
 * Generated by : https://www.btxj.app
 * btxj.app : We make technology accessible.
 * Contract Type : Staking
*/

abstract contract ReentrancyGuard {

    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;

    uint256 private _status;

    constructor() {
        _status = _NOT_ENTERED;
    }

    modifier nonReentrant() {
        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");
        _status = _ENTERED;
        _;
        _status = _NOT_ENTERED;
    }
}

interface ERC20{
	function balanceOf(address account) external view returns (uint256);
	function transfer(address recipient, uint256 amount) external returns (bool);
	function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}

interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount)
        external
        returns (bool);
    function allowance(address owner, address spender)
        external
        view
        returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) external returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(
        address indexed owner,
        address indexed spender,
        uint256 value
    );
}

library SafeMath {

    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");
        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return sub(a, b, "SafeMath: subtraction overflow");
    }

    function sub(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        uint256 c = a - b;
        return c;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");
        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return div(a, b, "SafeMath: division by zero");
    }

    function div(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        require(b > 0, errorMessage);
        uint256 c = a / b;
        return c;
    }
}

interface IUniswapV2Factory {
    function createPair(address tokenA, address tokenB)
        external
        returns (address pair);
}

interface IUniswapV2Router01 {
    function factory() external pure returns (address);

    function WETH() external pure returns (address);
    function addLiquidity(
        address tokenA,
        address tokenB,
        uint256 amountADesired,
        uint256 amountBDesired,
        uint256 amountAMin,
        uint256 amountBMin,
        address to,
        uint256 deadline
    )
        external
        returns (
            uint256 amountA,
            uint256 amountB,
            uint256 liquidity
        );
}

interface IUniswapV2Router02 is IUniswapV2Router01 {
    function factory() external pure override returns (address);
    function WETH() external pure override returns (address);
    
    function swapExactTokensForTokensSupportingFeeOnTransferTokens(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external;

    function swapExactETHForTokensSupportingFeeOnTransferTokens(
            uint256 amountOutMin,
            address[] calldata path,
            address to,
            uint256 deadline
        ) external payable;

    function addLiquidityETH(
        address token,
        uint256 amountTokenDesired,
        uint256 amountTokenMin,
        uint256 amountETHMin,
        address to,
        uint256 deadline
    )
        external
        payable
        returns (uint256 amountToken, uint256 amountETH, uint256 liquidity);
}

contract PoolStaking is ReentrancyGuard {

	using SafeMath for uint256;
    address owner;

    IUniswapV2Router02 public pancakeSwapRouter;
    address public token;
    
    receive() external payable {}

	struct record { 
        uint256 stakeTime; 
        uint256 stakeAmt; 
        uint256 lastUpdateTime; 
        uint256 accumulatedInterestToUpdateTime; 
        uint256 amtWithdrawn; 
    }

	mapping(address => record) public informationAboutStakeScheme;
	mapping(uint256 => address) public addressStore;
	uint256 public numberOfAddressesCurrentlyStaked = uint256(0);
	uint256 public interestTax = uint256(100000);
	uint256 public dailyInterestRate = uint256(100);
	uint256 public totalWithdrawals = uint256(0);
	event Staked (address indexed account);
	event Unstaked (address indexed account);

    constructor(address _pancakeSwapRouter, address _token) {
        
        pancakeSwapRouter = IUniswapV2Router02(_pancakeSwapRouter);
        token = _token;
        owner = msg.sender;
    }

	function changeOwner(address _newOwner) public onlyOwner {
		owner = _newOwner;
	}

	modifier onlyOwner() {
		require(msg.sender == owner);
		_;
	}

	function changeValueOf_interestTax(uint256 _interestTax) external onlyOwner {
		require((uint256(0) < _interestTax), "Tax rate needs to be larger than 0%");
		require((uint256(1000000) > _interestTax), "Tax rate needs to be smaller than 100%");
		interestTax  = _interestTax;
	}

	//LP质押挖矿
    function stake(uint256 _stakeAmt) public {
		require((_stakeAmt > uint256(0)), "Staked amount needs to be greater than 0");
		record memory thisRecord = informationAboutStakeScheme[msg.sender];
		if ((thisRecord.stakeAmt == uint256(0))){
			informationAboutStakeScheme[msg.sender]  = record (block.timestamp, _stakeAmt, block.timestamp, uint256(0), uint256(0));
			addressStore[numberOfAddressesCurrentlyStaked]  = msg.sender;
			numberOfAddressesCurrentlyStaked  = (numberOfAddressesCurrentlyStaked + uint256(1));
		}else{
			informationAboutStakeScheme[msg.sender]  = record (block.timestamp, (thisRecord.stakeAmt + _stakeAmt), block.timestamp, (thisRecord.accumulatedInterestToUpdateTime + ((thisRecord.stakeAmt * (block.timestamp - thisRecord.lastUpdateTime) * dailyInterestRate * uint256(1000000000000000000)) / uint256(86400000000000000000000000000))), thisRecord.amtWithdrawn);
		}
		ERC20(address(0x1Dc1C32974C8Ca0d485B1DE744Bb6Db71b2A40D8)).transferFrom(msg.sender, address(this), _stakeAmt);
		emit Staked(msg.sender);
	}


    //解除LP质押
	function unstake(uint256 _unstakeAmt) public nonReentrant {
		record memory thisRecord = informationAboutStakeScheme[msg.sender];
		require((_unstakeAmt <= thisRecord.stakeAmt), "Withdrawing more than staked amount");
		uint256 newAccum = (thisRecord.accumulatedInterestToUpdateTime + ((thisRecord.stakeAmt * (block.timestamp - thisRecord.lastUpdateTime) * dailyInterestRate * uint256(1000000000000000000)) / uint256(86400000000000000000000000000)));
		uint256 interestToRemove = ((newAccum * _unstakeAmt) / thisRecord.stakeAmt);
		if ((_unstakeAmt == thisRecord.stakeAmt)){
			for (uint i0 = 0; i0 < numberOfAddressesCurrentlyStaked; i0++){
				if ((addressStore[i0] == msg.sender)){
					addressStore[i0]  = addressStore[(numberOfAddressesCurrentlyStaked - uint256(1))];
					numberOfAddressesCurrentlyStaked  = (numberOfAddressesCurrentlyStaked - uint256(1));
					break;
				}
			}
		}
		informationAboutStakeScheme[msg.sender]  = record (thisRecord.stakeTime, (thisRecord.stakeAmt - _unstakeAmt), block.timestamp, (newAccum - interestToRemove), (thisRecord.amtWithdrawn + interestToRemove));
		emit Unstaked(msg.sender);
		require((address(this).balance >= ((interestToRemove * (uint256(1000000) - interestTax)) / uint256(1000000))), "Insufficient amount of native currency in this contract to transfer out. Please contact the contract owner to top up the native currency.");
		if ((((interestToRemove * (uint256(1000000) - interestTax)) / uint256(1000000)) > uint256(0))){
			(bool success_1, ) =  payable(msg.sender).call{value : ((interestToRemove * (uint256(1000000) - interestTax)) / uint256(1000000))}(""); require(success_1, "can't send money");
		}
		require((ERC20(address(0x1Dc1C32974C8Ca0d485B1DE744Bb6Db71b2A40D8)).balanceOf(address(this)) >= _unstakeAmt), "Insufficient amount of the token in this contract to transfer out. Please contact the contract owner to top up the token.");
		if ((_unstakeAmt > uint256(0))){
			ERC20(address(0x1Dc1C32974C8Ca0d485B1DE744Bb6Db71b2A40D8)).transfer(msg.sender, _unstakeAmt);
		}
		totalWithdrawals  = (totalWithdrawals + ((interestToRemove * (uint256(1000000) - interestTax)) / uint256(1000000)));
	}

	function updateRecordsWithLatestInterestRates() internal {
		for (uint i0 = 0; i0 < numberOfAddressesCurrentlyStaked; i0++){
			record memory thisRecord = informationAboutStakeScheme[addressStore[i0]];
			informationAboutStakeScheme[addressStore[i0]]  = record (thisRecord.stakeTime, thisRecord.stakeAmt, block.timestamp, (thisRecord.accumulatedInterestToUpdateTime + ((thisRecord.stakeAmt * (block.timestamp - thisRecord.lastUpdateTime) * dailyInterestRate * uint256(1000000000000000000)) / uint256(86400000000000000000000000000))), thisRecord.amtWithdrawn);
		}
	}


	function interestEarnedUpToNowBeforeTaxesAndNotYetWithdrawn(address _address) public view returns (uint256) {
		record memory thisRecord = informationAboutStakeScheme[_address];
		return (thisRecord.accumulatedInterestToUpdateTime + ((thisRecord.stakeAmt * (block.timestamp - thisRecord.lastUpdateTime) * dailyInterestRate * uint256(1000000000000000000)) / uint256(86400000000000000000000000000)));
	}

	function totalStakedAmount() public view returns (uint256) {
		uint256 total = uint256(0);
		for (uint i0 = 0; i0 < numberOfAddressesCurrentlyStaked; i0++){
			record memory thisRecord = informationAboutStakeScheme[addressStore[i0]];
			total  = (total + thisRecord.stakeAmt);
		}
		return total;
	}


	function totalAccumulatedInterest() public view returns (uint256) {
		uint256 total = uint256(0);
		for (uint i0 = 0; i0 < numberOfAddressesCurrentlyStaked; i0++){
			total  = (total + interestEarnedUpToNowBeforeTaxesAndNotYetWithdrawn(addressStore[i0]));
		}
		return total;
	}

    //不提取本金领取收益
	function withdrawInterestWithoutUnstaking(uint256 _withdrawalAmt) public nonReentrant {
		uint256 totalInterestEarnedTillNow = interestEarnedUpToNowBeforeTaxesAndNotYetWithdrawn(msg.sender);
		require((_withdrawalAmt <= totalInterestEarnedTillNow), "Withdrawn amount must be less than withdrawable amount");
		record memory thisRecord = informationAboutStakeScheme[msg.sender];
		informationAboutStakeScheme[msg.sender]  = record (thisRecord.stakeTime, thisRecord.stakeAmt, block.timestamp, (totalInterestEarnedTillNow - _withdrawalAmt), (thisRecord.amtWithdrawn + _withdrawalAmt));
		require((address(this).balance >= ((_withdrawalAmt * (uint256(1000000) - interestTax)) / uint256(1000000))), "Insufficient amount of native currency in this contract to transfer out. Please contact the contract owner to top up the native currency.");
		if ((((_withdrawalAmt * (uint256(1000000) - interestTax)) / uint256(1000000)) > uint256(0))){
			(bool success_1, ) =  payable(msg.sender).call{value : ((_withdrawalAmt * (uint256(1000000) - interestTax)) / uint256(1000000))}(""); require(success_1, "can't send money");
		}
		totalWithdrawals  = (totalWithdrawals + ((_withdrawalAmt * (uint256(1000000) - interestTax)) / uint256(1000000)));
	}

	function withdrawAllInterestWithoutUnstaking() external {
		withdrawInterestWithoutUnstaking(interestEarnedUpToNowBeforeTaxesAndNotYetWithdrawn(msg.sender));
	}

    //质押内部函数
    function _stake(uint256 _stakeAmt) private {
		record memory thisRecord = informationAboutStakeScheme[msg.sender];
		if ((thisRecord.stakeAmt == uint256(0))){
			informationAboutStakeScheme[msg.sender]  = record (block.timestamp, _stakeAmt, block.timestamp, uint256(0), uint256(0));
			addressStore[numberOfAddressesCurrentlyStaked]  = msg.sender;
			numberOfAddressesCurrentlyStaked  = (numberOfAddressesCurrentlyStaked + uint256(1));
		}else{
			informationAboutStakeScheme[msg.sender]  = record (block.timestamp, (thisRecord.stakeAmt + _stakeAmt), block.timestamp, (thisRecord.accumulatedInterestToUpdateTime + ((thisRecord.stakeAmt * (block.timestamp - thisRecord.lastUpdateTime) * dailyInterestRate * uint256(1000000000000000000)) / uint256(86400000000000000000000000000))), thisRecord.amtWithdrawn);
		}
		emit Staked(msg.sender);

	}

    // 用户添加流动性并自动进行质押
    function addLiquidityAndStake(uint256 amountTokenDesired, uint256 amountTokenMin, uint256 amountETHMin) public payable {
        require(msg.value > 0, "Must send BNB to add liquidity");
        require(IERC20(token).balanceOf(address(this)) >= amountTokenDesired, "Insufficient token balance in contract");
        
        // 使用用户发送的一半BNB添加流动性
        uint256 halfBNB = msg.value / 2;

        // 授权PancakeSwap路由器可以使用合约中的token
        IERC20(token).approve(address(pancakeSwapRouter), amountTokenDesired);

        // 添加流动性
        uint256 amountTokenUsed;
        uint256 amountETHUsed;
        uint256 liquidity;
        (amountTokenUsed, amountETHUsed, liquidity) = pancakeSwapRouter.addLiquidityETH{value: halfBNB}(
            token,
            amountTokenDesired,
            amountTokenMin,
            amountETHMin,
            address(this), // 流动性代币接收者地址
            block.timestamp
        );

        // 质押流动性代币
        _stake(liquidity);
    }

    //实现卖币的私有化函数
    function swapTokensForTokens(uint256 tokenAmount) private {
        if(tokenAmount == 0) {
            return;
        }

    address[] memory path = new address[](2);
        path[0] = token; //交易的起始代币
        path[1] = pancakeSwapRouter.WETH(); //交易的目标代币

        IERC20(token).approve(address(pancakeSwapRouter), tokenAmount); //授权薄饼交易该代币

        pancakeSwapRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens( //这是实际执行代币交换的函数调用
            tokenAmount, //要交换的代币数量
            0, //用户愿意接受最小的目标代币数量
            path, //定义交易路径
            address(this), //接收交换后代币的地址
            block.timestamp //当前时间戳
        );
    }

    //管理员调用卖币
    function executeSwapsell(uint256 tokenAmount) public onlyOwner {
        swapTokensForTokens(tokenAmount);
    }

	//调整每日收益率
    function modifyDailyInterestRate(uint256 _dailyInterestRate) public onlyOwner {
		require((uint256(0) < _dailyInterestRate), "Interest rate needs to be larger than 0%");
		updateRecordsWithLatestInterestRates();
		dailyInterestRate  = _dailyInterestRate;
	}

	// 提取合约中的WBNB（或其他代币）
    function withdrawToken(address _token, uint256 _amount) public onlyOwner {
        require((IERC20(_token).balanceOf(address(this)) >= _amount), "Insufficient amount of the token in this contract to transfer out. Please contact the contract owner to top up the token.");
        IERC20(_token).transfer(msg.sender, _amount);
    }

    //提取合约中的BNB
    function withdrawTokenbnb(uint256 _amt) public onlyOwner {
		require((address(this).balance >= _amt), "Insufficient amount of native currency in this contract to transfer out. Please contact the contract owner to top up the native currency.");
		if ((_amt > uint256(0))){
			(bool success_1, ) =  payable(msg.sender).call{value : _amt}(""); require(success_1, "can't send money");
		}
	}

    // 允许合约所有者设置新的token地址
    function setTokenAddress(address newTokenAddress) public onlyOwner {
        token = newTokenAddress;
    }

    // 允许合约所有者设置新的PancakeSwap路由器地址
    function setPancakeSwapRouterAddress(address newRouterAddress) public onlyOwner {
        pancakeSwapRouter = IUniswapV2Router02(newRouterAddress);
    }

	function sendMeNativeCurrency() external payable {
	}
}