{"FreeShibaInu.sol":{"content":"/**\r\n\r\n___________                       _________.__    ._____.          .___              \r\n\\_   _____/______   ____   ____  /   _____/|  |__ |__\\_ |__ _____  |   | ____  __ __ \r\n |    __) \\_  __ \\_/ __ \\_/ __ \\ \\_____  \\ |  |  \\|  || __ \\\\__  \\ |   |/    \\|  |  \\\r\n |     \\   |  | \\/\\  ___/\\  ___/ /        \\|   Y  \\  || \\_\\ \\/ __ \\|   |   |  \\  |  /\r\n \\___  /   |__|    \\___  \u003e\\___  \u003e_______  /|___|  /__||___  (____  /___|___|  /____/ \r\n     \\/                \\/     \\/        \\/      \\/        \\/     \\/         \\/       \r\n\r\n\r\nTelegram: https://t.me/FreeShibaInuOfficialBsc\t\t\t\t\t\t\t\t\t\t\r\n */\r\n\r\n// SPDX-License-Identifier: unlicensed\r\npragma solidity ^0.8.9;\r\n\r\nimport \"./Libraries.sol\";\r\n\r\n/**\r\n * Contract Code\r\n */\r\ncontract FreeShibaInu is IBEP20, Ownable {\r\n    using SafeMath for uint256;\r\n    using SignedSafeMath for int256;\r\n\r\n    // Events\r\n    event OwnerEnableTrading(uint256 _deadBlocks,uint256 timestamp);\r\n    event OwnerSwitchTradingStatus(bool enabled,uint256 timestamp);\r\n    event OwnerSetMarketingWallet(address oldMarketingWallet,address marketing);\r\n    event OwnerSetTeamWallet(address oldTeamWallet,address team);\r\n    event OwnerSetGameWallet(address oldGameWallet,address game);\r\n    event OwnerSetBuyFees(uint8 game,uint8 team,uint8 marketing,uint8 liquidity);\r\n    event OwnerSetSellFees(uint8 game,uint8 team,uint8 marketing,uint8 liquidity);\r\n    event OwnerSetLimits(uint256 maxTxBase1000,uint256 maxWalletBase1000);\r\n    event OwnerSetSwapSetting(uint256 swapThresholdBase10000,bool enabled);\r\n    event OwnerSwitchSameBlock(bool enabled, uint256 timestamp);\r\n    event OwnerSetFeeExempt(address account,bool enabled);\r\n    event OwnerSetTxLimitExempt(address account,bool enabled);\r\n    event OwnerBlacklistAddress(address account,bool enabled);\r\n    event OwnerSetPresaleAddress(address presaler);\r\n\r\n    // Mappings\r\n    mapping (address =\u003e uint256) _rBalance;\r\n    mapping (address =\u003e mapping (address =\u003e uint256)) _allowances;\r\n    mapping (address =\u003e bool) public isFeeExempt;\r\n    mapping (address =\u003e bool) public isTxLimitExempt;\r\n    mapping (address =\u003e uint256) private lastTrade;\r\n    mapping (address =\u003e bool) public blacklisted;\r\n\r\n    // Basic Contract Info\r\n    string constant _name = \"Free Shiba Inu\";\r\n    string constant _symbol = \"FSI\";\r\n    uint8 constant _decimals = 9;\r\n\r\n    bool tradingEnabled;\r\n    uint256 launchedAt;\r\n    uint256 deadBlocks;\r\n\r\n    // Supply Info\r\n    uint256 private constant MAX_UINT256 = ~uint256(0);\r\n    uint256 private constant MAX_SUPPLY = ~uint128(0);\r\n    uint256 private constant INITIAL_FRAGMENTS_SUPPLY = 10**8 * 10**_decimals;\r\n    uint256 private constant rSupply = MAX_UINT256 - (MAX_UINT256 % INITIAL_FRAGMENTS_SUPPLY);\r\n    \r\n    uint256 public _totalSupply;\r\n    uint256 public rate;\r\n\r\n    // Project \u0026 Burn Wallets\r\n    address public burnWallet = 0x000000000000000000000000000000000000dEaD;\r\n    address public marketingWallet = 0xa50D9E0eff12569D1D179EaCBcD6AE61229257A2; // \r\n    address public teamWallet = 0x068d852B1e881F57b8a1a64C4ef387344c1A7289;  //  \r\n    address public gameWallet = 0x2828B0F5c9dE9CF283ACFBB20A6fbF9De79c9E94;     //   \r\n \r\n    // Taxes\r\n    BuyFee public _buy;\r\n    SellFee public _sell;\r\n    uint256 public totalFee;\r\n\r\n    struct BuyFee{//Buy taxes set in constructor function\r\n        uint8 game;\r\n        uint8 team;\r\n        uint8 marketing;\r\n        uint8 liquidity;\r\n        uint8 total;\r\n    }\r\n    struct SellFee{//Sell taxes set in constructor function\r\n        uint8 game;\r\n        uint8 team;\r\n        uint8 marketing;\r\n        uint8 liquidity;\r\n        uint8 total;\r\n    }\r\n\r\n    // Limits\r\n    uint256 public _maxTxAmount = rSupply.div(100).mul(2);\r\n    uint256 public _maxWalletSize = rSupply.div(100).mul(3);\r\n    bool public sameBlockActive; \r\n\r\n    // DEX\r\n    IDEXRouter public router;\r\n    address public _pancakeRouterAddress=0x10ED43C718714eb63d5aA57B78B54704E256024E;\r\n    //Pancake Mainnet: 0x10ED43C718714eb63d5aA57B78B54704E256024E || Pancake Testnet: 0x9Ac64Cc6e4415144C455BD8E4837Fea55603e5c3\r\n    address public pair;\r\n    InterfaceLP public pairContract;\r\n\r\n    // SwapAndLiquify\r\n    bool public swapEnabled;\r\n    uint256 public swapThreshold = 1; // 0.1%\r\n    bool inSwap;\r\n    modifier swapping() { inSwap = true; _; inSwap = false; }\r\n\r\n    constructor () Ownable(msg.sender) {\r\n        router = IDEXRouter(_pancakeRouterAddress);\r\n        pair = IDEXFactory(router.factory()).createPair(router.WETH(), address(this));\r\n        _allowances[address(this)][address(router)] = type(uint256).max;\r\n\r\n        pairContract = InterfaceLP(pair);\r\n        _totalSupply = INITIAL_FRAGMENTS_SUPPLY;\r\n        rate = rSupply.div(_totalSupply);\r\n\r\n        // Exclude owner and this contract from fee and limits\r\n        isFeeExempt[msg.sender]=isFeeExempt[address(this)]=true;\r\n        isTxLimitExempt[msg.sender]=isTxLimitExempt[address(this)]=true;\r\n\r\n        // Set initial Buy taxes\r\n        _buy.game=2; _buy.team=3; _buy.marketing=2; _buy.liquidity=2;\r\n        _buy.total=_buy.game+_buy.team+_buy.marketing+_buy.liquidity;\r\n        \r\n        // Set initial Sell taxes\r\n        _sell.game=2; _sell.team=3; _sell.marketing=2; _sell.liquidity=2;\r\n        _sell.total=_sell.game+_sell.team+_sell.marketing+_sell.liquidity;\r\n        \r\n        _rBalance[msg.sender] = rSupply;\r\n        emit Transfer(address(0), msg.sender, _totalSupply);\r\n    }\r\n\r\n// Basic Internal Functions\r\n    function totalSupply() external view override returns (uint256) { return _totalSupply; }\r\n    function decimals() external pure override returns (uint8) { return _decimals; }\r\n    function symbol() external pure override returns (string memory) { return _symbol; }\r\n    function name() external pure override returns (string memory) { return _name; }\r\n    function getOwner() external view override returns (address) { return owner; }\r\n    function balanceOf(address account) public view override returns (uint256) {return _rBalance[account].div(rate);}\r\n    function allowance(address holder, address spender) external view override returns (uint256) { return _allowances[holder][spender];}\r\n    function approve(address spender, uint256 amount) public override returns (bool) {\r\n        _allowances[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n    function approveMax(address spender) external returns (bool) {\r\n        return approve(spender,type(uint256).max);\r\n    }\r\n    function transfer(address recipient, uint256 amount) external override returns (bool) {\r\n        return _transferFrom(msg.sender, recipient, amount);\r\n    }\r\n    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {\r\n        if(_allowances[sender][msg.sender] != type(uint256).max){\r\n            _allowances[sender][msg.sender] = _allowances[sender][msg.sender].sub(amount, \"Insufficient Allowance\");}\r\n        return _transferFrom(sender, recipient, amount);\r\n    }\r\n\r\n    receive() external payable { }\r\n\r\n// Transfer functions\r\n    function _transferFrom(address sender, address recipient, uint256 amount) internal returns (bool) {\r\n        require(isFeeExempt[sender]||tradingEnabled);\r\n        require(!blacklisted[sender] \u0026\u0026 !blacklisted[recipient]);\r\n        \r\n        if(inSwap){ return _basicTransfer(sender, recipient, amount); }\r\n        \r\n        if(sender != owner\r\n            \u0026\u0026 isFeeExempt[sender]\r\n            \u0026\u0026 isFeeExempt[recipient]\r\n            \u0026\u0026 recipient != owner\r\n            \u0026\u0026 recipient != address(0)\r\n            \u0026\u0026 sender != address(this)) {\r\n        // If SameBlock function is active, only one transaction per user per block is allowed\r\n            if (sameBlockActive) {\r\n                if (sender == pair){\r\n                    require(lastTrade[recipient] != block.number);\r\n                    lastTrade[recipient] = block.number;\r\n                } else {\r\n                    require(lastTrade[sender] != block.number);\r\n                    lastTrade[sender] = block.number;\r\n                    }\r\n                }\r\n            }\r\n        uint256 rAmount = amount.mul(rate);\r\n\r\n        if (sender != owner\r\n        \u0026\u0026 recipient != address(this)\r\n        \u0026\u0026 recipient != pair){\r\n            require((_rBalance[recipient] + rAmount) \u003c= _maxWalletSize,\"Total Holding is limited, you can not buy that much.\");}\r\n\r\n        require(rAmount \u003c= _maxTxAmount || isTxLimitExempt[sender] || isTxLimitExempt[recipient], \"TX Limit Exceeded\");\r\n\r\n        if(recipient == pair \u0026\u0026 shouldSwapBack()){ swapBack(); }\r\n\r\n        _rBalance[sender] = _rBalance[sender].sub(rAmount, \"Insufficient Balance\");\r\n\r\n        uint256 amountReceived = (!shouldTakeFee(sender) || !shouldTakeFee(recipient)) ? rAmount : takeFee(sender, rAmount,recipient);\r\n        _rBalance[recipient] = _rBalance[recipient].add(amountReceived);\r\n\r\n        emit Transfer(sender, recipient, amountReceived.div(rate));\r\n        return true;\r\n    }\r\n       \r\n    function _basicTransfer(address sender, address recipient, uint256 amount) internal returns (bool) {\r\n        uint256 rAmount = amount.mul(rate);\r\n        _rBalance[sender] = _rBalance[sender].sub(rAmount, \"Insufficient Balance\");\r\n        _rBalance[recipient] = _rBalance[recipient].add(rAmount);\r\n        emit Transfer(sender, recipient, rAmount.div(rate));\r\n        return true;\r\n    }\r\n\r\n// Taxes\r\n    function shouldTakeFee(address sender) internal view returns (bool) {\r\n        return !isFeeExempt[sender];\r\n    }\r\n\r\n    function takeFee(address sender, uint256 rAmount, address recipient) internal returns (uint256) {\r\n        bool Buy = sender == pair;\r\n        bool Sell = recipient == pair;\r\n        bool P2P = recipient != pair \u0026\u0026 sender != pair;\r\n        uint256 feeAmount;\r\n\r\n        if(Buy){totalFee = _buy.total;}\r\n        if(Sell){totalFee = _sell.total;}\r\n        if(P2P){totalFee == 0;}\r\n\r\n        if(launchedAt + deadBlocks \u003e= block.number){\r\n        feeAmount = rAmount.div(100).mul(99);}\r\n        else{feeAmount = rAmount.div(100).mul(totalFee);}\r\n\r\n        if (feeAmount \u003e0){\r\n        _rBalance[address(this)] = _rBalance[address(this)].add(feeAmount);\r\n        emit Transfer(sender, address(this), feeAmount.div(rate));\r\n        return rAmount.sub(feeAmount);}\r\n        \r\n        else return rAmount;\r\n    }\r\n\r\n// Swap and distribution  \r\n    function shouldSwapBack() internal view returns (bool) {\r\n        return msg.sender != pair\r\n        \u0026\u0026 !inSwap\r\n        \u0026\u0026 swapEnabled\r\n        \u0026\u0026 _rBalance[address(this)] \u003e= swapThreshold;\r\n    }\r\n\r\n    function swapBack() internal swapping {\r\n        uint256 tokensToSell = balanceOf(address(this));\r\n        if(tokensToSell \u003e _maxTxAmount){ tokensToSell = _maxTxAmount;}\r\n\r\n        uint256 liquidity = _buy.liquidity+_sell.liquidity;\r\n        uint256 marketing = _buy.marketing+_sell.marketing;\r\n        uint256 team = _buy.team+_sell.team;\r\n        uint256 game = _buy.game+_sell.game;\r\n        uint256 totalFees = _buy.total+_sell.total;\r\n\r\n        uint256 amountToLiquify = tokensToSell.div(totalFees).mul(liquidity).div(2);\r\n        uint256 amountToSwap = tokensToSell.sub(amountToLiquify);\r\n\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = router.WETH();\r\n\r\n        router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            amountToSwap,\r\n            0,\r\n            path,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n\r\n        uint256 amountBNB = address(this).balance;\r\n\r\n        uint256 totalBNBFee = totalFees.sub(liquidity.div(2));\r\n        \r\n        uint256 BNBLiquidity = amountBNB.mul(liquidity).div(totalBNBFee).div(2);\r\n        uint256 BNBGame = amountBNB.mul(game).div(totalBNBFee);\r\n        uint256 BNBMarketing = amountBNB.mul(marketing).div(totalBNBFee);\r\n        uint256 BNBTeam = amountBNB.mul(team).div(totalBNBFee);\r\n\r\n        if(BNBMarketing \u003e 0) {payable(marketingWallet).transfer(BNBMarketing);}\r\n        if(BNBGame \u003e 0) {payable(gameWallet).transfer(BNBGame);}\r\n        if(BNBTeam \u003e 0) {payable(teamWallet).transfer(BNBTeam);}\r\n\r\n        if(amountToLiquify \u003e 0){\r\n            router.addLiquidityETH{value: BNBLiquidity}(\r\n                address(this),\r\n                amountToLiquify,\r\n                0,\r\n                0,\r\n                owner,\r\n                block.timestamp\r\n            );\r\n        }\r\n    }\r\n\r\nfunction triggerswapback() public{\r\n    swapBack();\r\n}\r\n// Rebase functions\r\n    function rebase_percentage(bool reduce,uint256 _percentage_base1000) public onlyOwner returns (uint256 newSupply){\r\n        if(reduce){\r\n            newSupply = rebase(int(_totalSupply.div(1000).mul(_percentage_base1000)).mul(-1));\r\n        } else{\r\n            newSupply = rebase(int(_totalSupply.div(1000).mul(_percentage_base1000)));\r\n        }\r\n    }\r\n\r\n    function rebase(int256 supplyDelta) public onlyOwner returns (uint256) {\r\n        require(!inSwap, \"Try again\");\r\n\r\n        if (supplyDelta == 0) {\r\n            return _totalSupply;\r\n        }\r\n\r\n        if (supplyDelta \u003c 0) {\r\n            _totalSupply = _totalSupply.sub(uint256(-supplyDelta));\r\n        } else {\r\n            _totalSupply = _totalSupply.add(uint256(supplyDelta));\r\n        }\r\n\r\n        if (_totalSupply \u003e MAX_SUPPLY) {\r\n            _totalSupply = MAX_SUPPLY;\r\n        }\r\n\r\n        require(_totalSupply \u003e= 1, \"Minimum Supply must be 1 or higher\");\r\n\r\n        rate = rSupply.div(_totalSupply);\r\n        pairContract.sync();\r\n\r\n        return _totalSupply;\r\n    }\r\n\r\n// Owner Functions\r\n    function ownerEnableTrading(uint256 _deadBlocks) public onlyOwner {\r\n        require(!tradingEnabled,\"Trading already enabled\");\r\n        require(_deadBlocks \u003c=5,\"Cannot set more than 5 deadBlocks\");\r\n        tradingEnabled=true;\r\n        launchedAt=block.number;\r\n        swapEnabled=true;\r\n        sameBlockActive = true;\r\n        deadBlocks=_deadBlocks;\r\n        emit OwnerEnableTrading(_deadBlocks,block.timestamp);\r\n    }\r\n    function ownerSwitchTradingStatus(bool enabled) public onlyOwner {\r\n        tradingEnabled=enabled;\r\n        emit OwnerSwitchTradingStatus(enabled,block.timestamp);\r\n    }\r\n    function ownerSetMarketingWallet(address marketing) public onlyOwner {\r\n        require(marketing != marketingWallet,\"Cannot set same address than actual Wallet\");\r\n        address oldMarketingWallet=marketingWallet;\r\n        marketingWallet=marketing;\r\n        emit OwnerSetMarketingWallet(oldMarketingWallet,marketing);\r\n    }\r\n    function ownerSetTeamWallet(address team) public onlyOwner {\r\n        require(team != teamWallet,\"Cannot set same address than actual Wallet\");\r\n        address oldTeamWallet=teamWallet;\r\n        teamWallet=team;\r\n        emit OwnerSetTeamWallet(oldTeamWallet,team);\r\n    }\r\n    function ownerSetGameWallet(address game) public onlyOwner {\r\n        require(game != gameWallet,\"Cannot set same address than actual Wallet\");\r\n        address oldGameWallet=gameWallet;\r\n        gameWallet=game;\r\n        emit OwnerSetGameWallet(oldGameWallet,game);\r\n    }\r\n    function ownerSetBuyFees(uint8 game, uint8 team, uint8 marketing, uint8 liquidity) public onlyOwner {\r\n        _buy.game=game;\r\n        _buy.team=team;\r\n        _buy.marketing=marketing;\r\n        _buy.liquidity=liquidity;\r\n        _buy.total=game+team+marketing+liquidity;\r\n        emit OwnerSetBuyFees(game,team,marketing,liquidity);\r\n    }\r\n    function ownerSetSellFees(uint8 game, uint8 team, uint8 marketing, uint8 liquidity) public onlyOwner {\r\n        _sell.game=game;\r\n        _sell.team=team;\r\n        _sell.marketing=marketing;\r\n        _sell.liquidity=liquidity;\r\n        _sell.total=game+team+marketing+liquidity;\r\n        emit OwnerSetSellFees(game,team,marketing,liquidity);\r\n    }\r\n    function ownerSetLimits(uint256 maxTxBase1000, uint256 maxWalletBase1000) public onlyOwner {\r\n        require(maxTxBase1000 \u003e=5, \"Cannot set Max Transaction below 0.5%\");\r\n        require(maxWalletBase1000 \u003e=10, \"Cannot set Max Wallet below 1%\");\r\n        _maxTxAmount = rSupply/1000*maxTxBase1000;\r\n        _maxWalletSize = rSupply/1000*maxWalletBase1000;\r\n        emit OwnerSetLimits(maxTxBase1000,maxWalletBase1000);\r\n    }\r\n    function ownerSetSwapSetting(uint256 swapThresholdBase10000, bool enabled) public onlyOwner {\r\n        swapThreshold = rSupply/10000*swapThresholdBase10000;\r\n        swapEnabled = enabled;\r\n        emit OwnerSetSwapSetting(swapThresholdBase10000,enabled);\r\n    }\r\n    function ownerSwitchSameBlock(bool enabled) public onlyOwner {\r\n        sameBlockActive = enabled;\r\n        emit OwnerSwitchSameBlock(enabled,block.timestamp);\r\n    }\r\n    function ownerSetFeeExempt(address account, bool enabled) public onlyOwner {\r\n        isFeeExempt[account] = enabled;\r\n        emit OwnerSetFeeExempt(account,enabled);\r\n    }\r\n    function ownerSetTxLimitExempt(address account, bool enabled) public onlyOwner {\r\n        isTxLimitExempt[account] = enabled;\r\n        emit OwnerSetTxLimitExempt(account,enabled);\r\n    }\r\n    function ownerSetBlacklistAddress(address account, bool enabled) public onlyOwner {\r\n        blacklisted[account] = enabled;\r\n        emit OwnerBlacklistAddress(account,enabled);\r\n    }\r\n    function ownerSetPresaleAddress(address presaler) public onlyOwner {\r\n        isFeeExempt[presaler] = true;\r\n        isTxLimitExempt[presaler] = true;\r\n        emit OwnerSetPresaleAddress(presaler);\r\n    }\r\n}"},"Libraries.sol":{"content":"// SPDX-License-Identifier: unlicensed\r\n\r\npragma solidity ^0.8.9;\r\n\r\nlibrary SafeMath {\r\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            uint256 c = a + b;\r\n            if (c \u003c a) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b \u003e a) return (false, 0);\r\n            return (true, a - b);\r\n        }\r\n    }\r\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (a == 0) return (true, 0);\r\n            uint256 c = a * b;\r\n            if (c / a != b) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a / b);\r\n        }\r\n    }\r\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a % b);\r\n        }\r\n    }\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a + b;\r\n    }\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a - b;\r\n    }\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a * b;\r\n    }\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a % b;\r\n    }\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b \u003c= a, errorMessage);\r\n            return a - b;\r\n        }\r\n    }\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b \u003e 0, errorMessage);\r\n            return a / b;\r\n        }\r\n    }\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b \u003e 0, errorMessage);\r\n            return a % b;\r\n        }\r\n    }\r\n}\r\n\r\nlibrary SignedSafeMath {\r\n    function mul(int256 a, int256 b) internal pure returns (int256) {\r\n        return a * b;\r\n    }\r\n    function div(int256 a, int256 b) internal pure returns (int256) {\r\n        return a / b;\r\n    }\r\n    function sub(int256 a, int256 b) internal pure returns (int256) {\r\n        return a - b;\r\n    }\r\n    function add(int256 a, int256 b) internal pure returns (int256) {\r\n        return a + b;\r\n    }\r\n}\r\n\r\n/**\r\n * BEP20 standard interface.\r\n */\r\ninterface IBEP20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function decimals() external view returns (uint8);\r\n    function symbol() external view returns (string memory);\r\n    function name() external view returns (string memory);\r\n    function getOwner() external view returns (address);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address _owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * Basic access control mechanism\r\n */\r\nabstract contract Ownable {\r\n    address internal owner;\r\n    address private _previousOwner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor(address _owner) {\r\n        owner = _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(isOwner(msg.sender), \"!YOU ARE NOT THE OWNER\"); _;\r\n    }\r\n\r\n    function isOwner(address account) public view returns (bool) {\r\n        return account == owner;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(owner, address(0));\r\n        owner = address(0);\r\n    }\r\n}\r\n\r\ninterface InterfaceLP {\r\n    function sync() external;\r\n}\r\n\r\ninterface IDEXFactory {\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n}\r\n\r\ninterface IDEXRouter {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n"}}