{"Context.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"},"IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\ninterface IERC20 {\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"},"Ownable.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {Context} from \"./Context.sol\";\n\nabstract contract Ownable is Context {\n    address private _owner;\n\n    error OwnableUnauthorizedAccount(address account);\n\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"},"Stake.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport \"./Ownable.sol\";\nimport \"./IERC20.sol\";\n\ncontract DPG_Stake is Ownable {\n    IERC20 public immutable DPG;\n\n    event UserStaked(address indexed User, uint256 DPGAmount, uint256 PaymentTokenAmount);\n    event UserUnstaked(address indexed User, uint256 DPGAmount);\n    event UserCollectedReward(address indexed User, uint256 RewardAmount);\n\n    struct NewStake {\n        uint256 DPGStaked;\n        uint256 PaymentTokenPaid;\n        uint256 StakeTime;\n        uint256 StakePlan;\n        bool UnStaked;\n    }\n\n    struct Sub {\n        address SubAddress;\n        uint256 Level;\n    }\n\n    struct Plans {\n        uint256 Duration;\n        uint256 RewardRatePerSecond;\n    }\n\n    IERC20 public PaymentToken;\n    address public FundsPool;\n    uint256 public DPGPrice;\n    uint256 public MarketingProfit;\n    uint256 public FirstLevelMarketingProfit;\n    uint256 public TotalStakedDPG;\n    Plans[] public StakingPlans;\n\n    bool public OwnerLock;\n\n    mapping(address =\u003e NewStake[]) public User;\n    mapping(address =\u003e Sub[]) public Referees;\n    mapping(address =\u003e address) public Referrer;\n    mapping(address =\u003e uint256) public CollectTime;\n    mapping(address =\u003e uint256) public DirectRefererProfit;\n\n    constructor() Ownable(_msgSender()) {\n        PaymentToken = IERC20(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);\n        DPG = IERC20(0x72C1Cc8e5a103FcD4d12Dc20b91e5D95505789B3);\n        FundsPool = address(this);\n        DPGPrice = 100;\n        MarketingProfit = 5;\n        FirstLevelMarketingProfit = 8;\n        StakingPlans.push(Plans(365 days, 14275));\n        CollectTime[_msgSender()] = block.timestamp;\n        OwnerLock = false;\n    }\n\n    // External Functions\n\n    function Stake(uint256 amount, address referrer, uint256 plan) external {\n        require(OwnerLock == false, \"Staking is Locked\");\n        require(_msgSender() != owner(), \"Owner Cannot Stake\");\n        require(StakingPlans[plan].Duration != 0, \"Staking Plan is not Valid\");\n        require(amount \u003e= 100 ether, \"Stake Amount Should Be Greater than 100\");\n        uint256 PaymentTokentoDPG = (amount * 100000) / DPGPrice;\n        uint256 totalstakedpg = TotalStakedDPG + PaymentTokentoDPG;\n        require(totalstakedpg \u003c= 50000000000 ether, \"Maximum Stake Reached\");\n        address _referrer = SetReferrer(referrer);\n        uint256 ReferrerReward = amount * 5 / 100;\n        DirectRefererProfit[_referrer] += ReferrerReward;\n        PaymentToken.transferFrom(_msgSender(), FundsPool, amount);\n        TotalStakedDPG += PaymentTokentoDPG;\n        CollectTime[_msgSender()] = block.timestamp;\n        User[_msgSender()].push(NewStake(PaymentTokentoDPG, amount, block.timestamp, plan, false));\n        emit UserStaked(msg.sender, amount, PaymentTokentoDPG);\n    }\n\n    function UnStake() external {\n        uint256 unstakeamount;\n        NewStake[] memory user = User[_msgSender()];\n        for (uint256 i = 0; i \u003c user.length; i++) {\n            if (user[i].UnStaked == false) {\n                if (user[i].StakeTime + StakingPlans[user[i].StakePlan].Duration \u003c block.timestamp) {\n                    unstakeamount += user[i].DPGStaked;\n                    user[i].UnStaked = true;\n                }\n            }\n        }\n        require(unstakeamount \u003e 0, \"There is Nothing to UnStake\");\n        CollectReward();\n        TotalStakedDPG -= unstakeamount;\n        DPG.transfer(_msgSender(), unstakeamount);\n        emit UserUnstaked(msg.sender, unstakeamount);\n    }\n\n    // Public Functions\n\n    function CollectReward() public {\n        uint256 time = CollectTime[_msgSender()];\n        uint256 userreward = CalculateUserReward(_msgSender(), time);\n        uint256 usersubsreward = CalculateRefrralReward(_msgSender());\n        uint256 reward = userreward + usersubsreward + DirectRefererProfit[msg.sender];\n        require(reward \u003e 1 ether, \"Insufficient Amount\");\n        PaymentToken.transfer(_msgSender(), reward - (1 ether));\n        CollectTime[_msgSender()] = block.timestamp;\n        DirectRefererProfit[msg.sender] = 0;\n        emit UserCollectedReward(msg.sender, reward);\n    }\n\n    // Private Functions\n\n    function SetReferrer(address referrer) private returns (address) {\n        address finalreferrer;\n        address userreferrer = Referrer[_msgSender()];\n        if (userreferrer == address(0)) {\n            if (referrer == address(0) || User[referrer].length == 0 || referrer == _msgSender()) {\n                finalreferrer = owner();\n            } else {\n                finalreferrer = referrer;\n            }\n            Referrer[_msgSender()] = finalreferrer;\n            Referees[finalreferrer].push(Sub(_msgSender(), 1));\n            if (Referrer[finalreferrer] != address(0)) {\n                Referees[Referrer[finalreferrer]].push(Sub(_msgSender(), 2));\n                if (Referrer[Referrer[finalreferrer]] != address(0)) {\n                    Referees[Referrer[Referrer[finalreferrer]]].push(Sub(_msgSender(), 3));\n                }\n            }\n        } else {\n            finalreferrer = userreferrer;\n        }\n        return finalreferrer;\n    }\n\n    function CalculateUserReward(address _user, uint256 collecttime) private view returns (uint256) {\n        uint256 reward;\n        Plans[] memory stakingplans = StakingPlans;\n        NewStake[] memory user = User[_user];\n        for (uint256 i = 0; i \u003c user.length; i++) {\n            uint256 finishtime = user[i].StakeTime + stakingplans[user[i].StakePlan].Duration;\n            uint256 time;\n            if (collecttime \u003c user[i].StakeTime) {\n                collecttime = user[i].StakeTime;\n            }\n            if (finishtime \u003c block.timestamp) {\n                time = finishtime - collecttime;\n            } else {\n                time = block.timestamp - collecttime;\n            }\n            uint256 userreward =\n                stakingplans[user[i].StakePlan].RewardRatePerSecond * time * user[i].PaymentTokenPaid / 1e12;\n            reward += userreward;\n        }\n        return (reward);\n    }\n\n    function CalculateRefrralReward(address _user) private view returns (uint256) {\n        uint256 reward;\n        uint256 time = CollectTime[_user];\n        uint256 marketingprofit = MarketingProfit;\n        uint256 firstlevelmarketingprofit = FirstLevelMarketingProfit;\n        uint256 variablemarketingprofit;\n        Sub[] memory sub = Referees[_user];\n        for (uint256 i = 0; i \u003c sub.length; i++) {\n            if (sub[i].Level == 1) {\n                variablemarketingprofit = firstlevelmarketingprofit;\n            } else {\n                variablemarketingprofit = marketingprofit;\n            }\n            uint256 subprofit = CalculateUserReward(sub[i].SubAddress, time) * variablemarketingprofit / 100;\n            reward += subprofit;\n        }\n        return reward;\n    }\n\n    // ADMIN Functions\n\n    function ChangeFundsPool(address pool) external onlyOwner {\n        FundsPool = pool;\n    }\n\n    function ChangePaymentToken(address token) external onlyOwner {\n        PaymentToken = IERC20(token);\n    }\n\n    function LockStake(bool lock) external onlyOwner {\n        OwnerLock = lock;\n    }\n\n    function ChangeDPGPrice(uint256 price) external onlyOwner {\n        DPGPrice = price;\n    }\n\n    function ChangeMarketingProfit(uint256 mp) external onlyOwner {\n        MarketingProfit = mp;\n    }\n\n    function ChangeFirstLevelMarketingProfit(uint256 flmp) external onlyOwner {\n        FirstLevelMarketingProfit = flmp;\n    }\n\n    function ChangeStakingDuration(uint256 duration, uint256 rate) external onlyOwner {\n        StakingPlans.push(Plans(duration, rate));\n    }\n\n    function Withdraw(uint256 amount) external onlyOwner {\n        PaymentToken.transfer(_msgSender(), amount);\n    }\n\n    // Query Functions\n\n    function GetAllUserStakes(address user) external view returns (NewStake[] memory) {\n        return User[user];\n    }\n\n    function GetUserReferees(address user) external view returns (Sub[] memory) {\n        return Referees[user];\n    }\n\n    function GetUserReferrer(address user) external view returns (address) {\n        return Referrer[user];\n    }\n\n    function GetUserLastCollectTime(address user) external view returns (uint256) {\n        return CollectTime[user];\n    }\n\n    function GetUserProfit(address user) external view returns (uint256) {\n        return CalculateUserReward(user, CollectTime[user]);\n    }\n\n    function GetUserRefrralProfit(address user) external view returns (uint256) {\n        return CalculateRefrralReward(user);\n    }\n\n    function GetUserDirectRefrralProfit(address user) external view returns (uint256) {\n        return DirectRefererProfit[user];\n    }\n\n    function GetTotalStakedDPG() external view returns (uint256) {\n        return TotalStakedDPG;\n    }\n\n    function GetPrices() external view returns (uint256, uint256, uint256) {\n        return (DPGPrice, MarketingProfit, FirstLevelMarketingProfit);\n    }\n\n    function GetPlans() external view returns (Plans[] memory) {\n        return StakingPlans;\n    }\n}\n"}}