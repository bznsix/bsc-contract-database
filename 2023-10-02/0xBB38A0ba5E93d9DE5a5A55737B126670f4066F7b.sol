pragma solidity >=0.7.0 <0.9.0;
// SPDX-License-Identifier: MIT

/**
 * Generated by : https://www.cues.sg
 * Cues.sg : We make technology accessible.
 * Contract Type : Exchange
*/

interface ERC20{
	function balanceOf(address account) external view returns (uint256);
	function transfer(address recipient, uint256 amount) external returns (bool);
	function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}

contract Exchange {

	address owner;
	uint256 public minExchange1To2amtInTermsOfCoinBEP20Token = uint256(2000000000000000000);
	uint256 public exchange1To2rate = uint256(12870000000000);
	uint256 public tax1To2rate = uint256(25000);
	uint256 public minExchange2To1amtInTermsOfCoinAntiBotLiquidityGeneratorToken = uint256(25740000000000);
	uint256 public exchange2To1rate = uint256(77700000000000);
	uint256 public tax2To1rate = uint256(25000);
	event Exchanged (address indexed tgt);

	constructor() {
		owner = msg.sender;
	}

	//This function allows the owner to specify an address that will take over ownership rights instead. Please double check the address provided as once the function is executed, only the new owner will be able to change the address back.
	function changeOwner(address _newOwner) public onlyOwner {
		owner = _newOwner;
	}

	modifier onlyOwner() {
		require(msg.sender == owner);
		_;
	}

/**
 * Function changeValueOf_minExchange1To2amtInTermsOfCoinBEP20Token
 * Notes for _minExchange1To2amtInTermsOfCoinBEP20Token : 1 Coin BEP20Token is represented by 10^18.
 * The function takes in 1 variable, (zero or a positive integer) _minExchange1To2amtInTermsOfCoinBEP20Token. It can only be called by functions outside of this contract. It does the following :
 * checks that the function is called by the owner of the contract
 * updates minExchange1To2amtInTermsOfCoinBEP20Token as _minExchange1To2amtInTermsOfCoinBEP20Token
*/
	function changeValueOf_minExchange1To2amtInTermsOfCoinBEP20Token(uint256 _minExchange1To2amtInTermsOfCoinBEP20Token) external onlyOwner {
		minExchange1To2amtInTermsOfCoinBEP20Token  = _minExchange1To2amtInTermsOfCoinBEP20Token;
	}

/**
 * Function changeValueOf_exchange1To2rate
 * Notes for _exchange1To2rate : Number of Coin BEP20Token (1 Coin BEP20Token is represented by 10^18) to 1 Coin AntiBotLiquidityGeneratorToken (represented by 1).
 * The function takes in 1 variable, (zero or a positive integer) _exchange1To2rate. It can only be called by functions outside of this contract. It does the following :
 * checks that the function is called by the owner of the contract
 * updates exchange1To2rate as _exchange1To2rate
*/
	function changeValueOf_exchange1To2rate(uint256 _exchange1To2rate) external onlyOwner {
		exchange1To2rate  = _exchange1To2rate;
	}

/**
 * Function changeValueOf_tax1To2rate
 * Notes for _tax1To2rate : 10000 is one percent
 * The function takes in 1 variable, (zero or a positive integer) _tax1To2rate. It can only be called by functions outside of this contract. It does the following :
 * checks that the function is called by the owner of the contract
 * checks that 0 is strictly less than _tax1To2rate
 * checks that 1000000 is strictly greater than _tax1To2rate
 * updates tax1To2rate as _tax1To2rate
*/
	function changeValueOf_tax1To2rate(uint256 _tax1To2rate) external onlyOwner {
		require((uint256(0) < _tax1To2rate), "Tax rate needs to be larger than 0%");
		require((uint256(1000000) > _tax1To2rate), "Tax rate needs to be smaller than 100%");
		tax1To2rate  = _tax1To2rate;
	}

/**
 * Function changeValueOf_minExchange2To1amtInTermsOfCoinAntiBotLiquidityGeneratorToken
 * Notes for _minExchange2To1amtInTermsOfCoinAntiBotLiquidityGeneratorToken : 1 Coin AntiBotLiquidityGeneratorToken is represented by 10^9.
 * The function takes in 1 variable, (zero or a positive integer) _minExchange2To1amtInTermsOfCoinAntiBotLiquidityGeneratorToken. It can only be called by functions outside of this contract. It does the following :
 * checks that the function is called by the owner of the contract
 * updates minExchange2To1amtInTermsOfCoinAntiBotLiquidityGeneratorToken as _minExchange2To1amtInTermsOfCoinAntiBotLiquidityGeneratorToken
*/
	function changeValueOf_minExchange2To1amtInTermsOfCoinAntiBotLiquidityGeneratorToken(uint256 _minExchange2To1amtInTermsOfCoinAntiBotLiquidityGeneratorToken) external onlyOwner {
		minExchange2To1amtInTermsOfCoinAntiBotLiquidityGeneratorToken  = _minExchange2To1amtInTermsOfCoinAntiBotLiquidityGeneratorToken;
	}

/**
 * Function changeValueOf_exchange2To1rate
 * Notes for _exchange2To1rate : Number of Coin AntiBotLiquidityGeneratorToken (1 Coin AntiBotLiquidityGeneratorToken is represented by 10^9) to 1 Coin BEP20Token (represented by 1).
 * The function takes in 1 variable, (zero or a positive integer) _exchange2To1rate. It can only be called by functions outside of this contract. It does the following :
 * checks that the function is called by the owner of the contract
 * updates exchange2To1rate as _exchange2To1rate
*/
	function changeValueOf_exchange2To1rate(uint256 _exchange2To1rate) external onlyOwner {
		exchange2To1rate  = _exchange2To1rate;
	}

/**
 * Function changeValueOf_tax2To1rate
 * Notes for _tax2To1rate : 10000 is one percent
 * The function takes in 1 variable, (zero or a positive integer) _tax2To1rate. It can only be called by functions outside of this contract. It does the following :
 * checks that the function is called by the owner of the contract
 * checks that 0 is strictly less than _tax2To1rate
 * checks that 1000000 is strictly greater than _tax2To1rate
 * updates tax2To1rate as _tax2To1rate
*/
	function changeValueOf_tax2To1rate(uint256 _tax2To1rate) external onlyOwner {
		require((uint256(0) < _tax2To1rate), "Tax rate needs to be larger than 0%");
		require((uint256(1000000) > _tax2To1rate), "Tax rate needs to be smaller than 100%");
		tax2To1rate  = _tax2To1rate;
	}

/**
 * Function exchange1To2
 * Minimum Exchange Amount : Variable minExchange1To2amtInTermsOfCoinBEP20Token
 * The function takes in 1 variable, (zero or a positive integer) v0. It can be called by functions both inside and outside of this contract. It does the following :
 * checks that v0 is greater than or equals to minExchange1To2amtInTermsOfCoinBEP20Token
 * calls ERC20(Address 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56)'s at transferFrom function  with variable sender as (the address that called this function), variable recipient as (the address of this contract), variable amount as v0
 * checks that (ERC20(Address 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56)'s at balanceOf function  with variable recipient as (the address of this contract)) is greater than or equals to (((v0) * (tax1To2rate)) / (10000))
 * if (((v0) * (tax1To2rate)) / (10000)) is strictly greater than 0 then (calls ERC20(Address 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56)'s at transfer function  with variable recipient as (the owner of this contract), variable amount as (((v0) * (tax1To2rate)) / (10000)))
 * checks that (ERC20(Address 0x273aDa5300b3a32cB10aAD2b7960e4C5fd8BF345)'s at balanceOf function  with variable recipient as (the address of this contract)) is greater than or equals to (((((v0) * ((1000000) - (tax1To2rate))) / (1000000)) * (exchange1To2rate)) / (1000000000000000000))
 * if (((((v0) * ((1000000) - (tax1To2rate))) / (1000000)) * (exchange1To2rate)) / (1000000000000000000)) is strictly greater than 0 then (calls ERC20(Address 0x273aDa5300b3a32cB10aAD2b7960e4C5fd8BF345)'s at transfer function  with variable recipient as (the address that called this function), variable amount as (((((v0) * ((1000000) - (tax1To2rate))) / (1000000)) * (exchange1To2rate)) / (1000000000000000000)))
 * emits event Exchanged with inputs the address that called this function
*/
	function exchange1To2(uint256 v0) public {
		require((v0 >= minExchange1To2amtInTermsOfCoinBEP20Token), "Too little exchanged");
		ERC20(address(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56)).transferFrom(msg.sender, address(this), v0);
		require((ERC20(address(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56)).balanceOf(address(this)) >= ((v0 * tax1To2rate) / uint256(10000))), "Insufficient amount of the token in this contract to transfer out. Please contact the contract owner to top up the token.");
		if ((((v0 * tax1To2rate) / uint256(10000)) > uint256(0))){
			ERC20(address(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56)).transfer(owner, ((v0 * tax1To2rate) / uint256(10000)));
		}
		require((ERC20(address(0x273aDa5300b3a32cB10aAD2b7960e4C5fd8BF345)).balanceOf(address(this)) >= ((((v0 * (uint256(1000000) - tax1To2rate)) / uint256(1000000)) * exchange1To2rate) / uint256(1000000000000000000))), "Insufficient amount of the token in this contract to transfer out. Please contact the contract owner to top up the token.");
		if ((((((v0 * (uint256(1000000) - tax1To2rate)) / uint256(1000000)) * exchange1To2rate) / uint256(1000000000000000000)) > uint256(0))){
			ERC20(address(0x273aDa5300b3a32cB10aAD2b7960e4C5fd8BF345)).transfer(msg.sender, ((((v0 * (uint256(1000000) - tax1To2rate)) / uint256(1000000)) * exchange1To2rate) / uint256(1000000000000000000)));
		}
		emit Exchanged(msg.sender);
	}

/**
 * Function exchange2To1
 * Minimum Exchange Amount : Variable minExchange2To1amtInTermsOfCoinAntiBotLiquidityGeneratorToken
 * The function takes in 1 variable, (zero or a positive integer) v0. It can be called by functions both inside and outside of this contract. It does the following :
 * checks that v0 is greater than or equals to minExchange2To1amtInTermsOfCoinAntiBotLiquidityGeneratorToken
 * calls ERC20(Address 0x273aDa5300b3a32cB10aAD2b7960e4C5fd8BF345)'s at transferFrom function  with variable sender as (the address that called this function), variable recipient as (the address of this contract), variable amount as v0
 * checks that (ERC20(Address 0x273aDa5300b3a32cB10aAD2b7960e4C5fd8BF345)'s at balanceOf function  with variable recipient as (the address of this contract)) is greater than or equals to (((v0) * (tax2To1rate)) / (10000))
 * if (((v0) * (tax2To1rate)) / (10000)) is strictly greater than 0 then (calls ERC20(Address 0x273aDa5300b3a32cB10aAD2b7960e4C5fd8BF345)'s at transfer function  with variable recipient as (the owner of this contract), variable amount as (((v0) * (tax2To1rate)) / (10000)))
 * checks that (ERC20(Address 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56)'s at balanceOf function  with variable recipient as (the address of this contract)) is greater than or equals to (((((v0) * ((1000000) - (tax2To1rate))) / (1000000)) * (exchange2To1rate)) / (1000000000))
 * if (((((v0) * ((1000000) - (tax2To1rate))) / (1000000)) * (exchange2To1rate)) / (1000000000)) is strictly greater than 0 then (calls ERC20(Address 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56)'s at transfer function  with variable recipient as (the address that called this function), variable amount as (((((v0) * ((1000000) - (tax2To1rate))) / (1000000)) * (exchange2To1rate)) / (1000000000)))
 * emits event Exchanged with inputs the address that called this function
*/
	function exchange2To1(uint256 v0) public {
		require((v0 >= minExchange2To1amtInTermsOfCoinAntiBotLiquidityGeneratorToken), "Too little exchanged");
		ERC20(address(0x273aDa5300b3a32cB10aAD2b7960e4C5fd8BF345)).transferFrom(msg.sender, address(this), v0);
		require((ERC20(address(0x273aDa5300b3a32cB10aAD2b7960e4C5fd8BF345)).balanceOf(address(this)) >= ((v0 * tax2To1rate) / uint256(10000))), "Insufficient amount of the token in this contract to transfer out. Please contact the contract owner to top up the token.");
		if ((((v0 * tax2To1rate) / uint256(10000)) > uint256(0))){
			ERC20(address(0x273aDa5300b3a32cB10aAD2b7960e4C5fd8BF345)).transfer(owner, ((v0 * tax2To1rate) / uint256(10000)));
		}
		require((ERC20(address(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56)).balanceOf(address(this)) >= ((((v0 * (uint256(1000000) - tax2To1rate)) / uint256(1000000)) * exchange2To1rate) / uint256(1000000000))), "Insufficient amount of the token in this contract to transfer out. Please contact the contract owner to top up the token.");
		if ((((((v0 * (uint256(1000000) - tax2To1rate)) / uint256(1000000)) * exchange2To1rate) / uint256(1000000000)) > uint256(0))){
			ERC20(address(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56)).transfer(msg.sender, ((((v0 * (uint256(1000000) - tax2To1rate)) / uint256(1000000)) * exchange2To1rate) / uint256(1000000000)));
		}
		emit Exchanged(msg.sender);
	}

/**
 * Function ownerWithdrawToken0
 * The function takes in 1 variable, (zero or a positive integer) _amt. It can be called by functions both inside and outside of this contract. It does the following :
 * checks that the function is called by the owner of the contract
 * checks that (ERC20(Address 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56)'s at balanceOf function  with variable recipient as (the address of this contract)) is greater than or equals to _amt
 * if _amt is strictly greater than 0 then (calls ERC20(Address 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56)'s at transfer function  with variable recipient as (the address that called this function), variable amount as _amt)
*/
	function ownerWithdrawToken0(uint256 _amt) public onlyOwner {
		require((ERC20(address(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56)).balanceOf(address(this)) >= _amt), "Insufficient amount of the token in this contract to transfer out. Please contact the contract owner to top up the token.");
		if ((_amt > uint256(0))){
			ERC20(address(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56)).transfer(msg.sender, _amt);
		}
	}

/**
 * Function ownerWithdrawToken1
 * The function takes in 1 variable, (zero or a positive integer) _amt. It can be called by functions both inside and outside of this contract. It does the following :
 * checks that the function is called by the owner of the contract
 * checks that (ERC20(Address 0x273aDa5300b3a32cB10aAD2b7960e4C5fd8BF345)'s at balanceOf function  with variable recipient as (the address of this contract)) is greater than or equals to _amt
 * if _amt is strictly greater than 0 then (calls ERC20(Address 0x273aDa5300b3a32cB10aAD2b7960e4C5fd8BF345)'s at transfer function  with variable recipient as (the address that called this function), variable amount as _amt)
*/
	function ownerWithdrawToken1(uint256 _amt) public onlyOwner {
		require((ERC20(address(0x273aDa5300b3a32cB10aAD2b7960e4C5fd8BF345)).balanceOf(address(this)) >= _amt), "Insufficient amount of the token in this contract to transfer out. Please contact the contract owner to top up the token.");
		if ((_amt > uint256(0))){
			ERC20(address(0x273aDa5300b3a32cB10aAD2b7960e4C5fd8BF345)).transfer(msg.sender, _amt);
		}
	}
}
