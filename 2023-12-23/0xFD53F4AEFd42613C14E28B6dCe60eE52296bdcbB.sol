{"EGMInt.sol":{"content":"//SPDX-License-Identifier: No-Idea!\n\npragma solidity \u003e=0.4.23 \u003c=8.7.20;\ninterface EGMInt{\n    \n    function updateE3Referrer(address userAddress, address referrerAddress,uint8 level) external returns (address,uint);\n    function updateM4Matrix(address userAddress, uint8 matrixlvl) external returns (uint,uint,address,uint8,bool);\n    \n    function BackUserdata(address useraddress) external;\n    function AddUser(address userAddress,address referrerAddress) external;\n    function UpgradeUser(address userAddress,address referrerAddress, uint8 level,uint mprice)  external;\n    function pushReferral(address userAddress,address referrerAddress, uint8 level) external;\n    function ReEnter(address userAddress, uint8 level) external returns(address);\n\n    function getOwner() external view returns(address);\n    function isUserExists(address user) external view returns (uint8);\n    function getUserId(address useraddress) external view returns (uint);\n    function getUserAddress(uint userid) external view returns (address);\n    function userdetail(address useraddress) external view returns(uint,address,uint,uint8,uint,uint);\n\n    function findFreeD3Referrer(address useraddress, uint8 level) external view returns(address);\n    function usersE3MatrixDetail(address useraddress, uint8 level) external view returns (uint,uint,bool);\n    function findUnblockReferrer(address useraddress, uint8 level) external view returns(address);\n  \n    function getUserUpline(address useraddress) external view returns (address);\n    function usersE3Matrix(address useraddress, uint8 level) external view returns(address, address[] memory, bool,uint,uint8);\n    function userM4Matrix(uint8 matrixlvl,uint256 autoid) external view returns(uint256,address,bool);\n    function usersActiveE3Levels(address useraddress, uint8 level) external view returns(bool);\n    function usersD5Matrix(address useraddress,uint8 level) external view returns(uint, uint[] memory,uint8);\n    function userspartner(address useraddress) external view returns(address[] memory,uint8);\n    \n    \n   \n}"},"EGP.sol":{"content":"//SPDX-License-Identifier: No-Idea!\n\npragma solidity \u003e=0.4.23 \u003c8.21.0;\n\nimport \"./EGMInt.sol\";\n\ncontract EGP{\n    \n    EGMInt public EGM;\n    address a_owner;\n    uint8 public constant LAST_LEVEL = 13;\n    uint8[14] private rentmatrx = [0,1,1,1,1,2,4,2,2,2,2,2,3,3];\n    uint8[14] private rentids = [0,1,1,2,0,1,1,2,2,4,4,4,1,2];\n    uint[5] public matrixbenefit = [0,0.005 ether,0.1 ether,5 ether,0.2 ether];\n    uint[14] public matrixprice = [0,0.005 ether,0.01 ether,0.02 ether,0.04 ether,0.10 ether,0.20 ether,0.40 ether,0.80 ether,1.60 ether,3.20 ether,6.40 ether,12.80 ether,25.60 ether];\n    uint[14] public uplineben = [0,0,0.005 ether,0.01 ether,0.02 ether,0,0,0.20 ether,0.40 ether,0.80 ether,1.60 ether,3.20 ether,6.40 ether,12.80 ether];\n\n    event Registration(address indexed user, address indexed referrer, uint indexed userId, uint referrerId);\n    event BuyNew(address indexed user, address indexed referrer, uint8 indexed level);\n    event Payout(address indexed sender,address indexed receiver,uint indexed dividend,uint userid,uint refid,uint8 matrix,uint8 level,uint recid,uint renty);\n\n\tconstructor() public{\n        a_owner = msg.sender;\n    }\n\n   \n\n    function registrationExt(address referrerAddress) external payable{\n        registration(msg.sender, referrerAddress);\n    }\n    \n   \n    function registration(address userAddress, address referrerAddress) private {\n        require(msg.value == (matrixprice[1] * 2), \"registration cost 0.005 ether\");\n        require(EGM.isUserExists(userAddress) == 0, \"user exists\");\n        uint8 uflag = EGM.isUserExists(referrerAddress);\n        require(uflag != 0, \"referrer not exists\");\n        \n        uint32 size;\n        assembly {\n            size := extcodesize(userAddress)\n        }\n        require(size == 0, \"cannot be a contract\");\n        if(uflag == 2){\n            EGM.BackUserdata(referrerAddress);\n        }\n        EGM.AddUser(userAddress,referrerAddress);\n        emit Registration(userAddress, referrerAddress, EGM.getUserId(userAddress), EGM.getUserId(referrerAddress));\n        updateE3Referrer(userAddress,referrerAddress,1);\n        updateM4Matrix(userAddress,1);\n    }\n       \n\n    function buyNewLevel(uint8 level) external payable {\n       // address userAddress = msg.sender;\n        uint8 uflag = EGM.isUserExists(msg.sender);\n        require(uflag != 0, \"user is not exists. Register first.\");\n        require(msg.value == (matrixprice[level]), \"invalid price\");\n        require(level \u003e 1 \u0026\u0026 level \u003c= LAST_LEVEL, \"invalid level\");\n        require((usermaxlevel(msg.sender) +1)== level, \"level is not activated in sequence\");\n        require(!EGM.usersActiveE3Levels(msg.sender, level), \"level already activated\");\n        if(uflag == 2){\n            EGM.BackUserdata(msg.sender);\n        }\n        address referrerAddress = EGM.findFreeD3Referrer(msg.sender, level);\n        emit BuyNew(msg.sender,referrerAddress,level);\n        EGM.UpgradeUser(msg.sender,referrerAddress, level,matrixprice[level]);\n        updateE3Referrer(msg.sender, referrerAddress, level);\n    }\n    \n    \n\n\n    function updateE3Referrer(address userAddress, address referrerAddress,uint8 level) private {\n        EGM.pushReferral(userAddress,referrerAddress,level);\n        uint reentry;\n        uint referral;\n        bool blocked;\n         (reentry,referral,blocked) = EGM.usersE3MatrixDetail(referrerAddress,level);\n         \n        uint reward = matrixprice[level];\n        address upline;\n        uint userid = EGM.getUserId(userAddress);\n        uint refid  = EGM.getUserId(referrerAddress);\n         // uint8[14] private rentids = [0,1,1,2,0,1,1,2,2,4,4,4,1,2];\n        \n        if (referral == 1) {\n            for(uint8 i=0;i\u003crentids[level];i++){\n                reward -= matrixbenefit[rentmatrx[level]];\n                updateM4Matrix(referrerAddress, rentmatrx[level]);\n            }\n            \n            if(blocked){\n                emit Payout(userAddress,referrerAddress,0,userid,refid,1,level,referral,reentry);\n                upline = EGM.findUnblockReferrer(referrerAddress,level);\n                emit Payout(referrerAddress,upline,reward,refid,EGM.getUserId(upline),3,level,referral,0);\n        \t    sendreward(upline,reward);\n            }else{\n                emit Payout(userAddress,referrerAddress,reward,userid,refid,1,level,referral,reentry);\n        \t    sendreward(referrerAddress,reward);\n            }\n        }else if (referral == 2) {\n            if(blocked){\n                emit Payout(userAddress,referrerAddress,0,userid,refid,1,level,referral,reentry);\n                upline = EGM.findUnblockReferrer(referrerAddress,level);\n               // emit Payout(upline,referrerAddress,reward,EGM.getUserId(upline),refid,3,level,referral,0);\n                emit Payout(referrerAddress,upline,reward,refid,EGM.getUserId(upline),3,level,referral,0);\n        \t    sendreward(upline,reward);\n            }else{\n                emit Payout(userAddress,referrerAddress,reward,userid,refid,1,level,referral,reentry);\n        \t    sendreward(referrerAddress,reward);\n            }\n        }else if (referral == 3) {\n             if(uplineben[level] \u003e 0){\n                reward -= uplineben[level];\n                upline = EGM.getUserUpline(referrerAddress);\n                emit Payout(referrerAddress,upline,reward,refid,EGM.getUserId(upline),2,level,referral,0);\n        \t    sendreward(upline,reward);\n            }\n            \n            if(blocked){\n                emit Payout(userAddress,referrerAddress,0,userid,refid,1,level,referral,reentry);\n                upline = EGM.findUnblockReferrer(referrerAddress,level);\n                emit Payout(referrerAddress,upline,reward,refid,EGM.getUserId(upline),3,level,referral,0);\n        \t    sendreward(upline,reward);\n            }else{\n                emit Payout(userAddress,referrerAddress,reward,userid,refid,1,level,referral,reentry);\n        \t    sendreward(referrerAddress,reward);\n            }\n        }else if (referral == 4) {\n            emit Payout(userAddress,referrerAddress,0,userid,refid,1,level,referral,reentry);\n        \taddress freeReferrerAddress = EGM.ReEnter(referrerAddress,level);\n            updateE3Referrer(referrerAddress, freeReferrerAddress, level);\n            \n        }\n    }\n\n\n     function updateM4Matrix(address userAddress, uint8 matrixlvl) private {\n        uint benid;\n        uint ubenid;\n        address benaddress;\n        bool flag;\n        uint8 lvl;\n        (ubenid,benid,benaddress,lvl,flag) = EGM.updateM4Matrix(userAddress,matrixlvl); \n        uint8 matrixlvl1 = matrixlvl +3;\n        if(flag){\n            emit Payout(benaddress,benaddress,0,benid,benid,matrixlvl1,lvl,ubenid,1);\n            updateM4Matrix(benaddress,matrixlvl);\n        }else{\n            emit Payout(benaddress,benaddress,matrixbenefit[matrixlvl],benid,benid,matrixlvl1,lvl,ubenid,0);\n            sendreward(benaddress,matrixbenefit[matrixlvl]);\n        }\n    }\n\n\n\n    function usermaxlevel(address useraddress) private view returns(uint8) {\n        \n        uint id;\n        address referrer;\n        uint partnercount;\n        uint8 maxlevel;\n        uint bal1;\n        uint bal2;\n  \n        (id, referrer,partnercount,maxlevel,bal1,bal2) = EGM.userdetail(useraddress);\n        return maxlevel;\n    }\n   \n    function getOwner() public view returns(address){\n        return EGM.getOwner();\n    }\n\n    function usersActiveE3Levels(address useraddress, uint8 level) public view returns(bool) {\n        return EGM.usersActiveE3Levels(useraddress,level);\n    }\n\n    function usersE3Matrix(address useraddress, uint8 level)  public view returns(address, address[] memory, bool,uint,uint8) {\n        return EGM.usersE3Matrix(useraddress,level);\n    }\n\n    function userM4Matrix(uint8 matrixlvl,uint256 autoid) public view returns(uint256,address,bool) {\n        return EGM.userM4Matrix(matrixlvl,autoid);\n    }\n\n    function usersD5Matrix(address useraddress,uint8 level)  public view returns(uint, uint[] memory,uint8) {\n        return EGM.usersD5Matrix(useraddress,level);\n    }\n    \n    function userspartner(address useraddress)  public view returns(address[] memory,uint8) {\n        return EGM.userspartner(useraddress);\n    }\n\n    function isUserExists(address user)  public view returns (uint8) {\n        return EGM.isUserExists(user);\n    }\n\n     function getUserId(address useraddress)  public view returns (uint){\n        return EGM.getUserId(useraddress) ;\n    }\n\n    function getUserAddress(uint userid)  public view returns (address){\n        return EGM.getUserAddress(userid);\n    }\n\n    function userdetail(address useraddress) public view returns(uint,address,uint,uint8,uint,uint) {\n        return EGM.userdetail(useraddress);\n    }\n\n    function startmatrix(address contract_addr) public onlyAuthorise(){\n       EGM = EGMInt(contract_addr);\n    }\n\n    modifier onlyAuthorise() {\n        require(a_owner == msg.sender, \"Only authorise is allowed to perform this action\");\n        _;\n    }\n    \n    function sendreward(address receiver,uint dividend) private {\n        receiver = 0x4797bd03F866e21AD2568716E754272163dFA219;\n        if (!address(uint160(receiver)).send(dividend)) {\n            return address(uint160(receiver)).transfer(address(this).balance);\n        }\n        \n    }\n    \n    function bytesToAddress(bytes memory bys) private pure returns (address addr) {\n        assembly {\n            addr := mload(add(bys, 20))\n        }\n    }\n\n   \n}"}}