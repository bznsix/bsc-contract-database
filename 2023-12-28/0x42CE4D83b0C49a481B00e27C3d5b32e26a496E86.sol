{"Address.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\n\npragma solidity ^0.8.0;\n\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\u0027t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length \u003e 0;\n    }\n    \n    /**\n     * @dev Replacement for Solidity\u0027s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n}"},"Claim.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./TransferHelper.sol\";\nimport \"./Address.sol\";\nimport \"./IRouter.sol\";\n\ncontract FeeClaim {\n    IRouter public swapRouter;\n\n    event BNBReceived(address indexed sender, uint256 amount);\n    event ClaimedToken(address indexed token, address receiver1, uint256 amount1, address receiver2, uint256 amount2, address claimer);\n    event ClaimedTokenAsWBNB(address indexed token, address receiver1, uint256 amount1, address receiver2, uint256 amount2, address claimer);\n    event ClaimedBNB(address receiver1, uint256 amount1, address receiver2, uint256 amount2, address claimer);\n\n    address public owner1; // Always get 30% of the fee\n    address public owner2; // Get whatever is left after owner1\n    address public wBASE;\n\n    constructor (address _owner1, address _owner2) {\n        owner1 = _owner1;\n        owner2 = _owner2;\n        IRouter _swapRouter = IRouter(address(0x10ED43C718714eb63d5aA57B78B54704E256024E)); // Swap Router (Pancake V2 BSC)\n        swapRouter = _swapRouter;\n        wBASE = _swapRouter.WETH();\n    }\n\n    fallback() external payable {\n        emit BNBReceived(msg.sender, msg.value);\n    }\n    receive() external payable {\n        emit BNBReceived(msg.sender, msg.value);\n    }\n    \n    function claimToken(address _token) public {\n        require(IERC20(_token).balanceOf(address(this)) \u003e 0, \"There is nothing to claim for this token\");\n\n        uint256 currentBalance = IERC20(_token).balanceOf(address(this));\n\n        // First pay 30% to owner1\n        uint256 feeOwner1 = (currentBalance * 30) / 100;\n        TransferHelper.safeTransfer(_token, owner1, feeOwner1);\n\n        // Pay remaining balance to owner2\n        uint256 feeOwner2 = IERC20(_token).balanceOf(address(this));\n        TransferHelper.safeTransfer(_token, owner2, feeOwner2);\n\n        emit ClaimedToken(_token, owner1, feeOwner1, owner2, feeOwner2, msg.sender);\n    }\n\n    function claimTokenAsWBNB(address _token, uint256 amountOutMin) public {\n        require((msg.sender == owner1) || (msg.sender == owner2), \"Only owners can claim fees\");\n        require(IERC20(_token).balanceOf(address(this)) \u003e 0, \"There is nothing to claim for this token\");\n\n        uint256 currentBalance = IERC20(_token).balanceOf(address(this));\n        uint256 currentWBalance = IERC20(wBASE).balanceOf(address(this));\n\n        address[] memory path = new address[](2);\n        path[0] = _token;\n        path[1] = wBASE;\n\n        if(IERC20(_token).allowance(address(this), address(swapRouter)) \u003c currentBalance) {\n            IERC20(_token).approve(address(swapRouter), type(uint256).max);\n        }\n\n        swapRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            currentBalance,\n            amountOutMin,\n            path,\n            address(this),\n            block.timestamp\n        );\n\n        uint256 newWBalance = IERC20(wBASE).balanceOf(address(this));\n        require(newWBalance \u003e= (currentWBalance + amountOutMin) , \"Swap to WBNB failed\");\n        \n        // First pay 30% to owner1\n        uint256 feeOwner1 = (newWBalance * 30) / 100;\n        TransferHelper.safeTransfer(wBASE, owner1, feeOwner1);\n\n        // Pay remaining balance to owner2\n        uint256 feeOwner2 = IERC20(wBASE).balanceOf(address(this));\n        TransferHelper.safeTransfer(wBASE, owner2, feeOwner2);\n\n        emit ClaimedTokenAsWBNB(_token, owner1, feeOwner1, owner2, feeOwner2, msg.sender);\n    }\n\n    function claimBNB() public {\n        require(address(this).balance \u003e 0, \"No BNB to claim\");\n\n        uint256 feeOwner1 = (address(this).balance * 30) / 100;\n        Address.sendValue(payable(owner1), feeOwner1);\n\n        uint256 feeOwner2 = address(this).balance;\n        Address.sendValue(payable(owner2), feeOwner2);\n\n        emit ClaimedBNB(owner1, feeOwner1, owner2, feeOwner2, msg.sender);\n    }\n\n    function changeOwnerAddress(address _newAddress) public {\n        require((msg.sender == owner1) || (msg.sender == owner2), \"Only owner can change his address\");\n        require(_newAddress != address(0), \"Can not set the 0 address\");\n        require(Address.isContract(_newAddress) == false, \"You can not set a contract address\");\n\n        if(msg.sender == owner1) {\n            owner1 = _newAddress;\n        }\n\n        if(msg.sender == owner2) {\n            owner2 = _newAddress;\n        }\n    }\n\n    function getAmountOutMin(address _token, uint256 _tokenSellTax) public view returns(uint256) {\n        require(IERC20(_token).balanceOf(address(this)) \u003e 0, \"There is nothing to claim for this token\");\n\n        uint256 tokenBal = IERC20(_token).balanceOf(address(this));\n        address[] memory path = new address[](2);\n        path[0] = _token;\n        path[1] = wBASE;\n\n        uint256[] memory amounts = swapRouter.getAmountsOut(tokenBal, path);\n\n        if(amounts[amounts.length - 1] \u003e 0) {\n            uint256 amountOutWithSlippage = (amounts[amounts.length - 1] * (999 - (_tokenSellTax*10))) / 1000; // Add 0.1% slippage \n            return amountOutWithSlippage;\n        } else {\n            return 0;\n        }\n    }\n}"},"IERC20.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 value) external returns(bool);\n    function transfer(address to, uint value) external returns (bool);\n}"},"IRouter.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\ninterface IRouter {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n}"},"TransferHelper.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\nlibrary TransferHelper {\n\n    function safeTransfer(address token, address to, uint256 value) internal {\n        // bytes4(keccak256(bytes(\u0027transfer(address,uint256)\u0027)));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(\n            success \u0026\u0026 (data.length == 0 || abi.decode(data, (bool))),\n            \u0027TransferHelper::safeTransfer: transfer failed\u0027\n        );\n    }\n\n    function safeTransferETH(address to, uint256 value) internal {\n        (bool success, ) = to.call{value: value}(new bytes(0));\n        require(\n            success, \n            \u0027TransferHelper::safeTransferETH: ETH transfer failed\u0027);\n    }\n}"}}