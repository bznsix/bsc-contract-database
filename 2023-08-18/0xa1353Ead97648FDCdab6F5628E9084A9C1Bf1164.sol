{"BatchTransferContract.sol":{"content":"pragma solidity ^0.4.23;\r\n\r\nimport \u0027./Erc20.sol\u0027;\r\nimport \u0027./SafeMath.sol\u0027;\r\n\r\ncontract BatchTransferContract{\r\n  using SafeMath for uint256;\r\n  \r\n  address owner;\r\n  \r\n  event EtherTransfer(address from, uint256 value);\r\n  event TokenTransfer(address from, uint256 value,address token);\r\n  event EtherClaim(address owner,uint256 value);\r\n  event TokenClaim(address owner,uint256 value,address token);\r\n  \r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n  \r\n  constructor() public{\r\n    owner = msg.sender;\r\n  }\r\n  \r\n  function() public payable {}\r\n  \r\n  function sendEther(address[] recipients,uint256[] values) public payable{\r\n    uint256 total = msg.value;\r\n    uint256 i=0;\r\n    for(i;i\u003crecipients.length;i++){\r\n      require(total \u003e= values[i]);\r\n      total = total.sub(values[i]);\r\n      recipients[i].transfer(values[i]);\r\n    }    \r\n    emit EtherTransfer(msg.sender,msg.value);\r\n  }\r\n  \r\n  function sendToken(address token,address[] recipients,uint256[] values) public payable{\r\n    uint256 total = 0;\r\n    ERC20 erc20 = ERC20(token);\r\n    uint256 i = 0;\r\n    for(i;i \u003c recipients.length;i++){\r\n      erc20.transferFrom(msg.sender,recipients[i],values[i]);\r\n      total += values[i];\r\n    }\r\n    emit TokenTransfer(msg.sender,total,token);\r\n    \r\n  }\r\n  \r\n  function claimEther() public onlyOwner{\r\n    uint256 balance = address(this).balance;\r\n    owner.transfer(balance);\r\n    emit EtherClaim(owner,balance);\r\n  }\r\n  \r\n  function claimToken(address token) public onlyOwner{\r\n    ERC20 erc20 = ERC20(token);\r\n    uint256 balance = erc20.balanceOf(this);\r\n    erc20.transfer(owner,balance);\r\n    emit TokenClaim(owner,balance,token);\r\n  }\r\n  \r\n}"},"Erc20.sol":{"content":"pragma solidity ^0.4.23;\r\n\r\ncontract ERC20{\r\n    function totalSupply() public view returns (uint256);\r\n    function balanceOf(address who) public view returns (uint256);\r\n    function transfer(address to, uint256 value) public returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    \r\n    function allowance(address owner, address spender) public view returns (uint256);\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n    function approve(address spender, uint256 value) public returns (bool);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n"},"SafeMath.sol":{"content":"pragma solidity ^0.4.23;\n\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n    uint256 c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b \u003e 0); // Solidity automatically throws when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\n    return c;\n  }\n\n  /**\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b \u003c= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    assert(c \u003e= a);\n    return c;\n  }\n}"}}