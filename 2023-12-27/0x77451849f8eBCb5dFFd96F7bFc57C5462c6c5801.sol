{"contract.sol":{"content":"// SPDX-License-Identifier: GPLv3\r\npragma solidity ^0.8.18;\r\n\r\nimport \"./SafeMath.sol\";\r\nimport \"./IERC20.sol\";\r\nimport \"./ReentrancyGuard.sol\";\r\n\r\ninterface IPancakeRouter01 {\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\ncontract Arowfi is ReentrancyGuard{\r\n    using SafeMath for uint256;\r\n    address private owner;\r\n    IERC20  private usdt;\r\n    IPancakeRouter01 private Router;\r\n    uint256 private Start_Time;\r\n    uint256 private time = 1 days;\r\n    uint256 public CO_ROI_Amount;\r\n    uint256 private CO_ROI_Amount_Next;\r\n    uint256 private lastdistribition;\r\n    uint256 private _totalreward;\r\n    uint256 public round;\r\n    uint256 public Pool_Sharing_Amount;\r\n    uint256 private Pool_Sharing_Amount_Next;\r\n    uint256 private TotalUser_For_This_Round;\r\n    uint256 public GrandupdateReward;\r\n    uint256 private _levelroi;\r\n    \r\n        struct upline {\r\n        address  upline;\r\n        uint256  referrals;\r\n        uint40   deposit_time;\r\n        uint256 Total_withdrawreward;\r\n        uint256 Total_levelROI;\r\n        uint256 Total_Differnciate;\r\n        bool    reinvest;\r\n        uint256 lasttime;\r\n    }\r\n        struct userinfo {\r\n        uint256  amount;\r\n        uint256  time;\r\n        uint256  DailyPercentage;\r\n        uint40   TotalPercentage;\r\n        uint256  withdrawreward;\r\n        uint256  maxrewad;\r\n        uint256  Direct;\r\n        uint256  levelROI;\r\n        bool     green;\r\n        uint256 TeamIncome;\r\n        uint256 userIncome;\r\n        uint256 Differnciate;\r\n        uint256 Co_Roi_reward;\r\n        uint256 poolreward_;\r\n        \r\n    }\r\n\r\n    struct loan\r\n    {\r\n        uint256 amount;\r\n        uint256 _time;\r\n        uint256 totalintrest_return;\r\n    }\r\n\r\n   mapping(address =\u003e upline) public Referrals;\r\n   mapping(address =\u003e userinfo) public user;\r\n   mapping(address =\u003e uint256) public Ranks;\r\n   mapping(address =\u003e uint256) public Capping;\r\n   mapping(uint256 =\u003e uint256) private RanksAmount;\r\n   mapping(uint256 =\u003e uint256) private Ranksincome;\r\n   mapping(uint256 =\u003e uint256) private DF_Income;\r\n   mapping(address =\u003e mapping(uint256 =\u003e bool)) public returnstatus;\r\n   mapping(address =\u003e mapping(uint256 =\u003e uint256)) private returntime;\r\n   mapping(address =\u003e loan) public LoanAmount;\r\n   mapping(address =\u003e mapping(uint256 =\u003e bool)) public LoanStatus;\r\n   mapping(address =\u003e mapping(uint256 =\u003e uint256)) public Intrest_Status;\r\n   mapping(address =\u003e mapping(uint256 =\u003e uint256)) private Loantime;\r\n   mapping(address =\u003e mapping(uint256 =\u003e bool)) private fiftysecondcondition;\r\n   mapping(address =\u003e mapping(uint256 =\u003e bool)) public rankComplete;\r\n   mapping(address =\u003e mapping(uint256 =\u003e bool)) public CoROI;\r\n   mapping(address =\u003e mapping(uint256 =\u003e bool)) public Pool_Sharing_Status;\r\n   mapping(address =\u003e address []) private _DirectArray;\r\n   mapping(string  =\u003e uint256) private Total_User_in_Ranks;\r\n   mapping(address =\u003e string) private user_Rank_Name;\r\n   \r\n   address []  TotalUser ;\r\n\r\n    constructor() {\r\n\r\n        owner=msg.sender;\r\n        Start_Time = uint256(block.timestamp);\r\n        usdt = IERC20(0x86A44139d929F6F3dB259B5f1C52d9Ab50d423da);\r\n        Router = IPancakeRouter01(0x10ED43C718714eb63d5aA57B78B54704E256024E);\r\n        RanksAmount[1] = 1000 ether;\r\n        RanksAmount[2] = 2000 ether;\r\n        RanksAmount[3] = 5000 ether;\r\n        RanksAmount[4] = 10000 ether;\r\n        RanksAmount[5] = 25000 ether;\r\n        RanksAmount[6] = 50000 ether;\r\n        RanksAmount[7] = 100000 ether;\r\n        RanksAmount[8] = 200000 ether;\r\n        RanksAmount[9] = 500000 ether;\r\n\r\n        Ranksincome[1] = 5000 ether;\r\n        Ranksincome[2] = 15000 ether;\r\n        Ranksincome[3] = 50000 ether;\r\n        Ranksincome[4] = 150000 ether;\r\n        Ranksincome[5] = 500000 ether;\r\n        Ranksincome[6] = 1000000 ether;\r\n        Ranksincome[7] = 2500000 ether;\r\n        Ranksincome[8] = 5000000 ether;\r\n        Ranksincome[9] = 10000000 ether;  \r\n\r\n        DF_Income[2] = 20;\r\n        DF_Income[3] = 25;\r\n        DF_Income[4] = 30;\r\n        DF_Income[5] = 35;\r\n        DF_Income[6] = 40;\r\n    }\r\n\r\n\r\n    \r\n     modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Not owner\");\r\n        _;\r\n    }\r\n\r\n\r\n    function Usd_to_Arowfi(uint256 amountIn) public view returns (uint256)\r\n    {\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(0x55d398326f99059fF775485246999027B3197955);\r\n        path[1] = address(usdt);\r\n        uint256[] memory amounts = Router.getAmountsOut(amountIn,path);\r\n        return amounts[1];\r\n    }\r\n\r\n\r\n\r\n    function _setUpline (address _addr, address  _upline) private {\r\n        if(Referrals [_addr].upline == address(0) \u0026\u0026 _upline != _addr \u0026\u0026 _addr != owner \u0026\u0026 (Referrals[_upline].deposit_time \u003e 0 || _upline == owner)) {\r\n            Referrals[_addr].upline = _upline;\r\n            Referrals[_upline].referrals++;\r\n        }\r\n    }\r\n      function IsUpline( address _upline) public view returns(bool status)\r\n    {\r\n        if(Referrals[msg.sender].upline == address(0) \u0026\u0026 _upline != msg.sender \u0026\u0026 msg.sender != owner \u0026\u0026 (Referrals[_upline].deposit_time \u003e 0 || _upline == owner)) \r\n        {\r\n            status = true;  \r\n        }\r\n        return status;\r\n    }\r\n      function ChakUpline( address _upline) public view returns(address add)\r\n    {\r\n        return Referrals[_upline].upline;\r\n    }\r\n    function DirectArray(address a) public view returns(address [] memory)\r\n    {\r\n        return _DirectArray[a];\r\n    }\r\n\r\n    function AddTeamIncome(address e , uint256 amo) private{\r\n        address currentReferrer = e; \r\n        for (uint256 i = 0; i \u003c 20; i++) \r\n        {\r\n            if (currentReferrer == address(0)) \r\n            {\r\n                break;\r\n            }\r\n            user[currentReferrer].TeamIncome +=amo;\r\n            currentReferrer = ChakUpline(currentReferrer);\r\n        }\r\n    }\r\n\r\n    function adduserinfo(uint256 _amount,uint256 adminfee) private{\r\n        GrandupdateReward += adminfee;\r\n        if(_amount \u003e= 1600 ether)\r\n        {\r\n           user[msg.sender].amount =_amount;\r\n           user[msg.sender].time   = uint40(block.timestamp);\r\n           if(GrandupdateReward \u003e 1000000 ether)\r\n           {\r\n            user[msg.sender].DailyPercentage =166500000000000000;\r\n           }\r\n           else{\r\n            user[msg.sender].DailyPercentage = 333000000000000000;\r\n           }\r\n           user[msg.sender].TotalPercentage = 1000;\r\n           user[msg.sender].maxrewad  = _amount*1000/100; \r\n           Capping[msg.sender] = _amount*1000/100;\r\n           user[msg.sender].green = true; \r\n                  \r\n        }\r\n        else\r\n        {\r\n        \r\n        user[msg.sender].amount =_amount;\r\n        user[msg.sender].time   = uint40(block.timestamp);\r\n           if(GrandupdateReward \u003e 1000000 ether)\r\n           {\r\n            user[msg.sender].DailyPercentage =166500000000000000;\r\n           }\r\n           else{\r\n            user[msg.sender].DailyPercentage = 333000000000000000;\r\n           }\r\n        user[msg.sender].TotalPercentage = 200;\r\n        user[msg.sender].maxrewad  = _amount*200/100;\r\n        Capping[msg.sender] = _amount*200/100;\r\n        }\r\n        usdt.transfer(owner,adminfee*5/100);\r\n        \r\n    }\r\n\r\n    function SIGNUP(address _referral,uint256 _amount) external \r\n    {\r\n        require(Referrals[msg.sender].upline == address(0), \"already register\");\r\n        require(IsUpline(_referral) == true, \"upline not found\");\r\n        require(_amount \u003e= 100 ether, \"min 100$\");\r\n        uint256 usdt_to_token = Usd_to_Arowfi(_amount);\r\n        _setUpline(msg.sender,_referral);\r\n        Referrals[msg.sender].deposit_time = uint40(block.timestamp);\r\n        Referrals[_referral].lasttime = uint40(block.timestamp);\r\n        user[_referral].Direct++;\r\n        user[msg.sender].userIncome += _amount;\r\n        Pool_Sharing_Amount_Next += _amount;\r\n        usdt.transferFrom(msg.sender,address(this),usdt_to_token);\r\n        AddTeamIncome(_referral,_amount);\r\n        _DirectArray[_referral].push(msg.sender);\r\n        TotalUser.push(msg.sender);\r\n        adduserinfo(_amount,usdt_to_token);\r\n        if(_amount \u003e= user[_referral].amount \u0026\u0026 user[_referral].Direct \u003e= 2 \u0026\u0026 user[_referral].TotalPercentage \u003c 1000 \u0026\u0026 block.timestamp \u003c Referrals[_referral].deposit_time + 15 days )\r\n        {\r\n            user[_referral].TotalPercentage += 100;\r\n            user[_referral].maxrewad += user[_referral].amount*100/100;\r\n            Capping[_referral] += user[_referral].amount*100/100;\r\n            user[_referral].Direct = 0;\r\n        }\r\n        }\r\n    \r\n    function updatedRanks(address _referral) private\r\n    {\r\n        if(user[_referral].TeamIncome \u003e= 10000000 ether \u0026\u0026 Referrals[_referral].referrals \u003e=20 \u0026\u0026 user[_referral].userIncome \u003e= 2000 ether \u0026\u0026 fiftysecondcondition[_referral][9] == true \u0026\u0026rankComplete[_referral][9] == false)\r\n        {\r\n            if(Ranks[_referral] \u003e 6){\r\n            Total_User_in_Ranks[user_Rank_Name[msg.sender]] -=1;  \r\n            }            \r\n            Ranks[_referral] =10;\r\n            rankComplete[_referral][9] = true;\r\n            if(Ranks[_referral] \u003e 6){\r\n            Total_User_in_Ranks[user_Rank_Name[msg.sender]] -=1; \r\n            } \r\n            user_Rank_Name[msg.sender] = \"Diamond\";\r\n            Total_User_in_Ranks[\"Diamond\"] +=1;\r\n\r\n        }\r\n        else if(user[_referral].TeamIncome \u003e= 5000000 ether \u0026\u0026 Referrals[_referral].referrals \u003e=20 \u0026\u0026 user[_referral].userIncome \u003e= 2000 ether\u0026\u0026 fiftysecondcondition[_referral][8] == true \u0026\u0026rankComplete[_referral][8] == false)\r\n        {\r\n            \r\n            Ranks[_referral] =9;\r\n            rankComplete[_referral][8] = true; \r\n            user_Rank_Name[msg.sender] = \"EmraldUser\";\r\n            Total_User_in_Ranks[\"EmraldUser\"] +=1; \r\n                        \r\n        }\r\n        else if(user[_referral].TeamIncome \u003e= 2500000 ether \u0026\u0026 Referrals[_referral].referrals \u003e=20 \u0026\u0026 user[_referral].userIncome \u003e= 2000 ether\u0026\u0026 fiftysecondcondition[_referral][7] == true \u0026\u0026rankComplete[_referral][7] == false)\r\n        {\r\n            if(Ranks[_referral] \u003e 6){\r\n            Total_User_in_Ranks[user_Rank_Name[msg.sender]] -=1;  \r\n            }\r\n            Ranks[_referral] =8;\r\n            rankComplete[_referral][7] = true;\r\n\r\n            user_Rank_Name[msg.sender] = \"gold\";\r\n            Total_User_in_Ranks[\"gold\"] +=1;  \r\n        }\r\n        else if(user[_referral].TeamIncome \u003e= 1000000 ether \u0026\u0026 Referrals[_referral].referrals \u003e=20 \u0026\u0026 user[_referral].userIncome \u003e= 2000 ether\u0026\u0026 fiftysecondcondition[_referral][6] == true \u0026\u0026rankComplete[_referral][6] == false)\r\n        {\r\n            Ranks[_referral] =7;\r\n            rankComplete[_referral][6] = true;\r\n            user_Rank_Name[msg.sender] = \"silver\";\r\n            Total_User_in_Ranks[\"silver\"] +=1;            \r\n        }\r\n        else if(user[_referral].TeamIncome \u003e= 500000 ether \u0026\u0026 Referrals[_referral].referrals \u003e=20 \u0026\u0026 user[_referral].userIncome \u003e= 2000 ether\u0026\u0026 fiftysecondcondition[_referral][5] == true \u0026\u0026rankComplete[_referral][5] == false)\r\n        {\r\n            Ranks[_referral] =6;\r\n            rankComplete[_referral][5] = true;\r\n        }\r\n        else if(user[_referral].TeamIncome \u003e= 150000 ether \u0026\u0026 Referrals[_referral].referrals \u003e=20 \u0026\u0026 user[_referral].userIncome \u003e= 1500 ether\u0026\u0026 fiftysecondcondition[_referral][4] == true \u0026\u0026rankComplete[_referral][4] == false)\r\n        {\r\n            Ranks[_referral] =5;\r\n            rankComplete[_referral][4] = true;\r\n        }\r\n        else if(user[_referral].TeamIncome \u003e= 50000 ether \u0026\u0026 Referrals[_referral].referrals \u003e=20 \u0026\u0026 user[_referral].userIncome \u003e= 1000 ether\u0026\u0026 fiftysecondcondition[_referral][3] == true\u0026\u0026 rankComplete[_referral][3] == false)\r\n        {\r\n            Ranks[_referral] =4;\r\n            rankComplete[_referral][3] = true;\r\n        }\r\n        else if(user[_referral].TeamIncome \u003e= 15000 ether \u0026\u0026 Referrals[_referral].referrals \u003e=20 \u0026\u0026 user[_referral].userIncome \u003e= 500 ether\u0026\u0026 fiftysecondcondition[_referral][2] == true\u0026\u0026rankComplete[_referral][2] == false)\r\n        {\r\n            Ranks[_referral] =3;\r\n            rankComplete[_referral][2] = true;\r\n        }  \r\n        else if(user[_referral].TeamIncome \u003e= 5000 ether \u0026\u0026 Referrals[_referral].referrals \u003e=20 \u0026\u0026 user[_referral].userIncome \u003e= 100 ether\u0026\u0026 fiftysecondcondition[_referral][1] == true\u0026\u0026 rankComplete[_referral][1] == false)\r\n        {\r\n            Ranks[_referral] =2;\r\n            rankComplete[_referral][1] = true;\r\n        }        \r\n    }\r\n\r\n\r\n\r\n    function getLoan(uint256 _rank) external nonReentrant\r\n    {\r\n        // require(isContract(msg.sender) == false ,\"this is contract\");\r\n        require(LoanStatus[msg.sender][_rank] == false ,\"already get\");\r\n        require(_rank \u003c  Ranks[msg.sender] ,\"error\");\r\n        require(_rank \u003c=  9 \u0026\u0026 _rank \u003e 0,\"please enter between 1 to 9\");\r\n        LoanAmount[msg.sender].amount += RanksAmount[_rank];\r\n        LoanStatus[msg.sender][_rank] = true;\r\n        uint256 _token = Usd_to_Arowfi(RanksAmount[_rank]);\r\n        usdt.transfer(msg.sender,_token);\r\n        Loantime[msg.sender][_rank] = uint256(block.timestamp);\r\n        Intrest_Status[msg.sender][_rank] = RanksAmount[_rank]*500000000000000000/100;\r\n    }\r\n\r\n    function ReturnLoan(uint256 _rank) external \r\n    {\r\n        // require(isContract(msg.sender) == false ,\"this is contract\");\r\n        require(returnstatus[msg.sender][_rank] == false ,\"error\");\r\n        uint256 _token_ = Usd_to_Arowfi(RanksAmount[_rank]);\r\n        usdt.transferFrom(msg.sender,address(this),_token_);\r\n        returnstatus[msg.sender][_rank] = true;\r\n        returntime[msg.sender][_rank] = uint256(block.timestamp);\r\n    }\r\n\r\n\r\n\r\n    function Checkintrest(address a) public view returns(uint256 b)\r\n    {\r\n        for(uint256 i=1 ; i \u003c= Ranks[a];i++)\r\n        {\r\n            if(block.timestamp \u003e Loantime[a][i] + time)\r\n            {\r\n                if(returnstatus[a][i] == false)\r\n                {\r\n                    uint256 t = (block.timestamp.sub(Loantime[a][i]))/time;\r\n                    b += (Intrest_Status[a][i]*t)/1e18;\r\n                }\r\n                else\r\n                {\r\n                    uint256 t = (returntime[a][i].sub(Loantime[a][i]))/time;\r\n                    b += (Intrest_Status[a][i]*t)/1e18;\r\n                }\r\n            }\r\n        }\r\n        b = b.sub(LoanAmount[a].totalintrest_return );\r\n        return b;\r\n    }\r\n\r\n\r\n    function CO_ROI() external onlyOwner\r\n    {\r\n        CO_ROI_Amount = CO_ROI_Amount_Next;\r\n        CO_ROI_Amount_Next=0;\r\n        Pool_Sharing_Amount = Pool_Sharing_Amount_Next;\r\n        Pool_Sharing_Amount_Next=0;\r\n        round +=1;\r\n        TotalUser_For_This_Round = TotalUser.length;  \r\n    }\r\n\r\n\r\n    function Withdraw_Pool_Sharing() external nonReentrant\r\n    {\r\n        // require(isContract(msg.sender) == false ,\"this is contract\");\r\n        require(block.timestamp \u003e Referrals[msg.sender].deposit_time + 15 days,\"wait 15 days\");\r\n        require(block.timestamp \u003c Start_Time + 300 days,\"time end\");\r\n        \r\n        if(block.timestamp.sub(Referrals[msg.sender].lasttime) \u003c 90 days  )\r\n        {\r\n              \r\n            require(Pool_Sharing_Status[msg.sender][round] == false,\"error\");\r\n            uint256 z = (Pool_Sharing_Amount*5/100)/TotalUser_For_This_Round;\r\n            user[msg.sender].poolreward_ += z;\r\n            Pool_Sharing_Status[msg.sender][round] = true;\r\n            if(z \u003e Capping[msg.sender])\r\n            {\r\n                z =Capping[msg.sender];\r\n                Capping[msg.sender] =0;\r\n            }else{\r\n                Capping[msg.sender] = Capping[msg.sender].sub(z);\r\n            }\r\n            uint256 __token_ = Usd_to_Arowfi(z);\r\n            usdt.transfer(msg.sender,__token_);\r\n        }\r\n    }\r\n\r\n    function Withdraw_CO_ROI() external nonReentrant\r\n    {\r\n        // require(isContract(msg.sender) == false ,\"this is contract\");\r\n        require(Ranks[msg.sender] \u003e 6 \u0026\u0026 Ranks[msg.sender] \u003c 11  ,\"ranks error\");\r\n        require(CoROI[msg.sender][round] == false,\"error\");\r\n               \r\n        uint256 y = Total_User_in_Ranks[user_Rank_Name[msg.sender]];\r\n        uint256 z = (CO_ROI_Amount*5/100)/y;\r\n\r\n            user[msg.sender].Co_Roi_reward += z;\r\n            CoROI[msg.sender][round] = true;\r\n            if(z \u003e Capping[msg.sender])\r\n            {\r\n                z =Capping[msg.sender];\r\n                Capping[msg.sender] =0;\r\n            }else{\r\n                Capping[msg.sender] = Capping[msg.sender].sub(z);\r\n            }     \r\n            uint256 __token_ = Usd_to_Arowfi(z);       \r\n            usdt.transfer(msg.sender,__token_);\r\n    }\r\n\r\n    function Re_Activation(uint256 _amount) external \r\n    {\r\n        require(Referrals[msg.sender].upline != address(0), \"not register\");\r\n        require(_amount \u003e= user[msg.sender].amount, \"error\");\r\n        uint256 token_amount = Usd_to_Arowfi(_amount);\r\n        usdt.transferFrom(msg.sender,address(this),token_amount); \r\n        address __referral = Referrals[msg.sender].upline;\r\n        Pool_Sharing_Amount_Next += _amount;\r\n        Referrals[msg.sender].reinvest = true;\r\n        user[msg.sender].userIncome += _amount;\r\n        AddTeamIncome(__referral,_amount);\r\n\r\n        adduserinfo(_amount,token_amount);\r\n        user[msg.sender].withdrawreward = 0;\r\n    }\r\n\r\n    function Check_ROI_Income(address _add) public view returns(uint256)\r\n    {\r\n        uint256 totalavalaiblereward;\r\n        if(Referrals[_add].reinvest == false){\r\n        uint256 totaltime = (block.timestamp.sub(user[_add].time))/(time);\r\n        uint256 totalreward = ((user[_add].amount*user[_add].DailyPercentage/100)/1e18)*totaltime;\r\n         totalavalaiblereward =  totalreward.sub(user[_add].withdrawreward);\r\n        if(user[_add].withdrawreward+totalavalaiblereward \u003e user[_add].maxrewad)\r\n        {\r\n            totalavalaiblereward = user[_add].maxrewad.sub(user[_add].withdrawreward);\r\n        }\r\n        }else{\r\n            totalavalaiblereward=0;\r\n        }\r\n        return totalavalaiblereward;\r\n    }\r\n\r\n\r\n    // function Revive_inactive_id(address _addr) external onlyOwner\r\n    // {\r\n    //     require(block.timestamp \u003e user[_addr].time+ 365 days,\"error\");\r\n    //     uint256 reward1 = Check_ROI_Income(_addr);\r\n    //     reward1 = reward1+user[_addr].levelROI+user[_addr].Differnciate;\r\n    //     uint256 token1 = Usd_to_Arowfi(reward1);\r\n    //     usdt.transfer(owner,token1);\r\n    // }\r\n\r\n    function WithdrawReward() external \r\n    {           \r\n        uint256 reward = Check_ROI_Income(msg.sender);\r\n        // require(reward \u003e 0, \"no reward\");\r\n        lastdistribition=0;\r\n        _totalreward=0;\r\n        uint256 s = Checkintrest(msg.sender);\r\n        _totalreward=reward;\r\n\r\n        uint256 levelreward = reward*10/100;\r\n        uint256 levelreward1 = reward*5/100;\r\n\r\n//......................................................................................reward\r\n        if( reward \u003e Capping[msg.sender] )\r\n        {\r\n           reward = Capping[msg.sender];\r\n           user[msg.sender].withdrawreward += reward;\r\n           CO_ROI_Amount_Next +=Capping[msg.sender];\r\n           Referrals[msg.sender].Total_withdrawreward += reward;\r\n           Capping[msg.sender] = 0;\r\n        }\r\n        else{\r\n            Capping[msg.sender] = Capping[msg.sender].sub(reward);\r\n            user[msg.sender].withdrawreward += reward;\r\n            CO_ROI_Amount_Next +=reward;\r\n            Referrals[msg.sender].Total_withdrawreward += reward;\r\n        }        \r\n//..............................................................................................level Roi\r\n        if( user[msg.sender].levelROI \u003e Capping[msg.sender] )\r\n        {\r\n           reward += Capping[msg.sender];\r\n           user[msg.sender].levelROI = user[msg.sender].levelROI.sub(Capping[msg.sender]);\r\n           Referrals[msg.sender].Total_levelROI += Capping[msg.sender];\r\n           Capping[msg.sender] = 0;\r\n        }\r\n        else{\r\n            Capping[msg.sender] = Capping[msg.sender].sub(user[msg.sender].levelROI);\r\n            Referrals[msg.sender].Total_levelROI += user[msg.sender].levelROI;\r\n            reward += user[msg.sender].levelROI;\r\n            user[msg.sender].levelROI = 0;\r\n        }\r\n//..............................................................................................DF income\r\n        if( user[msg.sender].Differnciate \u003e Capping[msg.sender] )\r\n        {\r\n           reward += Capping[msg.sender];\r\n           user[msg.sender].Differnciate = user[msg.sender].Differnciate.sub(Capping[msg.sender]);\r\n           Referrals[msg.sender].Total_Differnciate += Capping[msg.sender];\r\n           Capping[msg.sender] = 0;\r\n        }\r\n        else{\r\n            Capping[msg.sender] = Capping[msg.sender].sub(user[msg.sender].Differnciate);\r\n            Referrals[msg.sender].Total_Differnciate += user[msg.sender].Differnciate;\r\n            reward += user[msg.sender].Differnciate;\r\n            user[msg.sender].Differnciate = 0;\r\n        }\r\n\r\n        _setranks(msg.sender);    \r\n        updatedRanks(msg.sender);\r\n\r\n        if(reward\u003es)\r\n        {\r\n            reward = reward.sub(s);\r\n            LoanAmount[msg.sender].totalintrest_return += s;\r\n        }\r\n        else\r\n        {\r\n            LoanAmount[msg.sender].totalintrest_return += reward;\r\n            reward =0; \r\n        }\r\n        uint256 token2 = Usd_to_Arowfi(reward);\r\n        usdt.transfer(msg.sender,token2); \r\n        \r\n        address L1 = Referrals[msg.sender].upline;\r\n        if(L1 != address(0) \u0026\u0026  Referrals[L1].referrals \u003e0 || user[L1].green == true)\r\n        {\r\n            user[L1].levelROI += levelreward;\r\n            if(Ranks[L1] \u003e 1 \u0026\u0026 Ranks[L1] \u003c 7)\r\n            {\r\n                user[L1].Differnciate += _totalreward*DF_Income[Ranks[L1]]/100;\r\n                lastdistribition = DF_Income[Ranks[L1]];\r\n            }\r\n        }\r\n        address L2 = Referrals[L1].upline; \r\n        if(L2 != address(0) \u0026\u0026 Referrals[L2].referrals \u003e1 || user[L2].green == true)\r\n        {\r\n            user[L2].levelROI += levelreward1;\r\n            if(Ranks[L2] \u003e 1 \u0026\u0026 Ranks[L2] \u003c 7 \u0026\u0026 DF_Income[Ranks[L2]] \u003e lastdistribition)\r\n            {\r\n                user[L2].Differnciate += _totalreward*(DF_Income[Ranks[L2]].sub(lastdistribition))/100;\r\n                lastdistribition = DF_Income[Ranks[L2]];\r\n            }            \r\n        }\r\n\r\n        address L3 = Referrals[L2].upline;\r\n        if(L3 != address(0) \u0026\u0026 Referrals[L3].referrals \u003e2 || user[L3].green == true)\r\n        {\r\n            user[L3].levelROI += levelreward1;\r\n            if(Ranks[L3] \u003e 1 \u0026\u0026 Ranks[L3] \u003c 7 \u0026\u0026 DF_Income[Ranks[L3]] \u003e lastdistribition)\r\n            {\r\n                user[L3].Differnciate += _totalreward*(DF_Income[Ranks[L3]].sub(lastdistribition))/100;\r\n                lastdistribition = DF_Income[Ranks[L3]];\r\n            }            \r\n        }        \r\n\r\n        address L4 = Referrals[L3].upline;\r\n        if(L4 != address(0) \u0026\u0026 Referrals[L4].referrals \u003e3 || user[L4].green == true)\r\n        {\r\n            user[L4].levelROI += levelreward1;\r\n            if(Ranks[L4] \u003e 1 \u0026\u0026 Ranks[L4] \u003c 7 \u0026\u0026 DF_Income[Ranks[L4]] \u003e lastdistribition)\r\n            {\r\n                user[L4].Differnciate += _totalreward*(DF_Income[Ranks[L4]].sub(lastdistribition))/100;\r\n                lastdistribition = DF_Income[Ranks[L4]];\r\n            }            \r\n        }\r\n\r\n        address L5 = Referrals[L4].upline;\r\n        if(L5 != address(0) \u0026\u0026 Referrals[L5].referrals \u003e4 || user[L5].green == true)\r\n        {\r\n            user[L5].levelROI += levelreward1;\r\n            if(Ranks[L5] \u003e 1 \u0026\u0026 Ranks[L5] \u003c 7 \u0026\u0026 DF_Income[Ranks[L5]] \u003e lastdistribition)\r\n            {\r\n                user[L5].Differnciate += _totalreward*(DF_Income[Ranks[L5]].sub(lastdistribition))/100;\r\n                lastdistribition = DF_Income[Ranks[L5]];\r\n            }            \r\n        }\r\n\r\n        address L6 = Referrals[L5].upline;\r\n        if(L6 != address(0) \u0026\u0026 Referrals[L6].referrals \u003e5 || user[L6].green == true)\r\n        {\r\n            user[L6].levelROI += levelreward1;\r\n            if(Ranks[L6] \u003e 1 \u0026\u0026 Ranks[L6] \u003c 7 \u0026\u0026 DF_Income[Ranks[L6]] \u003e lastdistribition)\r\n            {\r\n                user[L6].Differnciate += _totalreward*(DF_Income[Ranks[L6]].sub(lastdistribition))/100;\r\n                lastdistribition = DF_Income[Ranks[L6]];\r\n            }            \r\n        }\r\n\r\n        address L7 = Referrals[L6].upline;\r\n        if(L7 != address(0) \u0026\u0026 Referrals[L7].referrals \u003e6 || user[L7].green == true)\r\n        {\r\n            user[L7].levelROI += levelreward1;\r\n            if(Ranks[L7] \u003e 1 \u0026\u0026 Ranks[L7] \u003c 7 \u0026\u0026 DF_Income[Ranks[L7]] \u003e lastdistribition)\r\n            {\r\n                user[L7].Differnciate += _totalreward*(DF_Income[Ranks[L7]].sub(lastdistribition))/100;\r\n                lastdistribition = DF_Income[Ranks[L7]];\r\n            }        \r\n        }\r\n\r\n        address L8 = Referrals[L7].upline;\r\n        if(L8 != address(0) \u0026\u0026 Referrals[L8].referrals \u003e7 || user[L8].green == true)\r\n        {\r\n            user[L8].levelROI += levelreward1;\r\n            if(Ranks[L8] \u003e 1 \u0026\u0026 Ranks[L8] \u003c 7 \u0026\u0026 DF_Income[Ranks[L8]] \u003e lastdistribition)\r\n            {\r\n                user[L8].Differnciate += _totalreward*(DF_Income[Ranks[L8]].sub(lastdistribition))/100;\r\n                lastdistribition = DF_Income[Ranks[L8]];\r\n            }            \r\n        }\r\n\r\n        address L9 = Referrals[L8].upline;\r\n        if(L9 != address(0) \u0026\u0026 Referrals[L9].referrals \u003e8 || user[L9].green == true)\r\n        {\r\n            user[L9].levelROI += levelreward1;\r\n            if(Ranks[L9] \u003e 1 \u0026\u0026 Ranks[L9] \u003c 7 \u0026\u0026 DF_Income[Ranks[L9]] \u003e lastdistribition)\r\n            {\r\n                user[L9].Differnciate += _totalreward*(DF_Income[Ranks[L9]].sub(lastdistribition))/100;\r\n                lastdistribition = DF_Income[Ranks[L9]];\r\n            }            \r\n        }\r\n\r\n        address L10 = Referrals[L9].upline;\r\n        if(L10 != address(0) \u0026\u0026 Referrals[L10].referrals \u003e 9 || user[L10].green == true)\r\n        {\r\n            user[L10].levelROI += levelreward1;\r\n            if(Ranks[L10] \u003e 1 \u0026\u0026 Ranks[L10] \u003c 7 \u0026\u0026 DF_Income[Ranks[L10]] \u003e lastdistribition)\r\n            {\r\n                user[L10].Differnciate += _totalreward*(DF_Income[Ranks[L10]].sub(lastdistribition))/100;\r\n                lastdistribition = DF_Income[Ranks[L10]];\r\n            }            \r\n        }\r\n\r\n        address L11 = Referrals[L10].upline;\r\n        if(L11 != address(0) \u0026\u0026 Referrals[L11].referrals \u003e10 || user[L11].green == true)\r\n        {\r\n            user[L11].levelROI += levelreward1;\r\n            if(Ranks[L11] \u003e 1 \u0026\u0026 Ranks[L11] \u003c 7 \u0026\u0026 DF_Income[Ranks[L11]] \u003e lastdistribition)\r\n            {\r\n                user[L11].Differnciate += _totalreward*(DF_Income[Ranks[L11]].sub(lastdistribition))/100;\r\n                lastdistribition = DF_Income[Ranks[L11]];\r\n            }            \r\n        }\r\n\r\n        address L12 = Referrals[L11].upline;\r\n        if(L12 != address(0) \u0026\u0026 Referrals[L12].referrals \u003e11 || user[L12].green == true)\r\n        {\r\n            user[L12].levelROI += levelreward1;\r\n            if(Ranks[L12] \u003e 1 \u0026\u0026 Ranks[L12] \u003c 7 \u0026\u0026 DF_Income[Ranks[L12]] \u003e lastdistribition)\r\n            {\r\n                user[L12].Differnciate += _totalreward*(DF_Income[Ranks[L12]].sub(lastdistribition))/100;\r\n                lastdistribition = DF_Income[Ranks[L12]];\r\n            }            \r\n        }\r\n\r\n        address L13 = Referrals[L12].upline;\r\n        if(L13 != address(0) \u0026\u0026 Referrals[L13].referrals \u003e12 || user[L13].green == true)\r\n        {\r\n            user[L13].levelROI += levelreward1;\r\n            if(Ranks[L13] \u003e 1 \u0026\u0026 Ranks[L13] \u003c 7 \u0026\u0026 DF_Income[Ranks[L13]] \u003e lastdistribition)\r\n            {\r\n                user[L13].Differnciate += _totalreward*(DF_Income[Ranks[L13]].sub(lastdistribition))/100;\r\n                lastdistribition = DF_Income[Ranks[L13]];\r\n            }            \r\n        }\r\n\r\n        address L14 = Referrals[L13].upline;\r\n        if(L14 != address(0) \u0026\u0026 Referrals[L14].referrals \u003e13 || user[L14].green == true)\r\n        {\r\n            user[L14].levelROI += levelreward1;\r\n            if(Ranks[L14] \u003e 1 \u0026\u0026 Ranks[L14] \u003c 7 \u0026\u0026 DF_Income[Ranks[L14]] \u003e lastdistribition)\r\n            {\r\n                user[L14].Differnciate += _totalreward*(DF_Income[Ranks[L14]].sub(lastdistribition))/100;\r\n                lastdistribition = DF_Income[Ranks[L14]];\r\n            }            \r\n        }\r\n        _levelroi = levelreward1;\r\n        distributinglevelreward(L14);\r\n        \r\n\r\n    }\r\n\r\n    function distributinglevelreward(address _L14) private\r\n    {\r\n        uint256 s =_levelroi;\r\n        address L15 = Referrals[_L14].upline;\r\n        \r\n        if(L15 != address(0) \u0026\u0026 Referrals[L15].referrals \u003e14 || user[L15].green == true)\r\n        {\r\n            user[L15].levelROI += s;\r\n            if(Ranks[L15] \u003e 1 \u0026\u0026 Ranks[L15] \u003c 7 \u0026\u0026 DF_Income[Ranks[L15]] \u003e lastdistribition)\r\n            {\r\n                user[L15].Differnciate += _totalreward*(DF_Income[Ranks[L15]].sub(lastdistribition))/100;\r\n                lastdistribition = DF_Income[Ranks[L15]];\r\n            }\r\n\r\n        }\r\n        address L16 = Referrals[L15].upline;\r\n        if(L16 != address(0) \u0026\u0026 Referrals[L16].referrals \u003e15 || user[L16].green == true)\r\n        {\r\n            user[L16].levelROI += s;\r\n            if(Ranks[L16] \u003e 1 \u0026\u0026 Ranks[L16] \u003c 7 \u0026\u0026 DF_Income[Ranks[L16]] \u003e lastdistribition)\r\n            {\r\n                user[L16].Differnciate += _totalreward*(DF_Income[Ranks[L16]].sub(lastdistribition))/100;\r\n                lastdistribition = DF_Income[Ranks[L16]];\r\n            }            \r\n        }\r\n        address L17 = Referrals[L16].upline;\r\n        if(L17 != address(0) \u0026\u0026 Referrals[L17].referrals \u003e16 || user[L17].green == true)\r\n        {\r\n            user[L17].levelROI += s;\r\n            if(Ranks[L17] \u003e 1 \u0026\u0026 Ranks[L17] \u003c 7 \u0026\u0026 DF_Income[Ranks[L17]] \u003e lastdistribition)\r\n            {\r\n                user[L17].Differnciate += _totalreward*(DF_Income[Ranks[L17]].sub(lastdistribition))/100;\r\n                lastdistribition = DF_Income[Ranks[L17]];\r\n            }            \r\n        }\r\n        address L18 = Referrals[L17].upline;\r\n        if(L18 != address(0) \u0026\u0026 Referrals[L18].referrals \u003e17 || user[L18].green == true)\r\n        {\r\n            user[L18].levelROI += s;\r\n            if(Ranks[L18] \u003e 1 \u0026\u0026 Ranks[L18] \u003c 7 \u0026\u0026 DF_Income[Ranks[L18]] \u003e lastdistribition)\r\n            {\r\n                user[L18].Differnciate += _totalreward*(DF_Income[Ranks[L18]].sub(lastdistribition))/100;\r\n                lastdistribition = DF_Income[Ranks[L18]];\r\n            }            \r\n        }\r\n        address L19 = Referrals[L18].upline;\r\n        if(L19 != address(0) \u0026\u0026 Referrals[L19].referrals \u003e18 || user[L19].green == true)\r\n        {\r\n            user[L19].levelROI += s;\r\n            if(Ranks[L19] \u003e 1 \u0026\u0026 Ranks[L19] \u003c 7 \u0026\u0026 DF_Income[Ranks[L19]] \u003e lastdistribition)\r\n            {\r\n                user[L19].Differnciate += _totalreward*(DF_Income[Ranks[L19]].sub(lastdistribition))/100;\r\n                lastdistribition = DF_Income[Ranks[L19]];\r\n            }            \r\n        }\r\n        address L20 = Referrals[L19].upline;\r\n        if(L20 != address(0) \u0026\u0026 Referrals[L20].referrals \u003e19 || user[L20].green == true)\r\n        {\r\n            user[L20].levelROI += s;\r\n            if(Ranks[L20] \u003e 1 \u0026\u0026 Ranks[L20] \u003c 7 \u0026\u0026 DF_Income[Ranks[L20]] \u003e lastdistribition)\r\n            {\r\n                user[L20].Differnciate += _totalreward*(DF_Income[Ranks[L20]].sub(lastdistribition))/100;\r\n                lastdistribition = DF_Income[Ranks[L20]];\r\n            }            \r\n        } \r\n    }\r\n\r\n    function _setranks(address a) private{\r\n\r\n        uint256 s = _DirectArray[a].length;\r\n        address [] memory t = _DirectArray[a];\r\n        if(s\u003e0)\r\n        {\r\n        for (uint256 i = 0; i \u003c s; i++) \r\n        {\r\n            if (t[i] == address(0)) \r\n            {\r\n                break;\r\n            }\r\n            __condition1(t[i],a);\r\n\r\n        }\r\n        }\r\n    }\r\n\r\n    function checkcondition(address _a,uint256 amou,address si,uint256 _rank) private\r\n    {\r\n        uint256 _totalamount ;\r\n        uint256 ss = _DirectArray[_a].length;\r\n        address [] memory t = _DirectArray[_a];\r\n        for (uint256 i = 0; i \u003c ss; i++) \r\n        {\r\n            if (t[i] != si) \r\n            {\r\n                _totalamount += user[t[i]].userIncome + user[t[i]].TeamIncome;\r\n            }\r\n        }\r\n        if(_totalamount \u003e= amou)\r\n        {\r\n            for(uint256 i = 0;i \u003c _rank;i++)\r\n            {\r\n                fiftysecondcondition[_a][i+1] = true;\r\n            }\r\n            \r\n        }\r\n    }\r\n\r\n    function __condition1(address _referral,address a) private{\r\n        if(Ranks[_referral] == 0)\r\n        {\r\n           if(user[_referral].userIncome + user[_referral].TeamIncome  \u003e= 5000000 ether)\r\n               {\r\n                  checkcondition(a,5000000 ether,_referral,9); \r\n               }\r\n            else if(user[_referral].userIncome + user[_referral].TeamIncome  \u003e= 2500000 ether)   \r\n            {\r\n                checkcondition(a,2500000 ether,_referral,8);  \r\n            }\r\n            else if(user[_referral].userIncome + user[_referral].TeamIncome  \u003e= 1250000 ether)   \r\n            {\r\n                   checkcondition(a,1250000 ether,_referral,7); \r\n            }\r\n            else if(user[_referral].userIncome + user[_referral].TeamIncome  \u003e= 500000 ether)   \r\n            {\r\n                checkcondition(a,500000 ether,_referral,6); \r\n            }\r\n            else if(user[_referral].userIncome + user[_referral].TeamIncome  \u003e= 250000 ether)   \r\n            {\r\n                checkcondition(a,250000 ether,_referral,5); \r\n            }           \r\n            else if(user[_referral].userIncome + user[_referral].TeamIncome  \u003e= 75000 ether)   \r\n            {\r\n                checkcondition(a,75000 ether,_referral,4);\r\n            }\r\n            else if(user[_referral].userIncome + user[_referral].TeamIncome  \u003e= 25000 ether)   \r\n            {\r\n                checkcondition(a,25000 ether,_referral,3); \r\n            }\r\n            else if(user[_referral].userIncome + user[_referral].TeamIncome  \u003e= 7500 ether)   \r\n            {\r\n                checkcondition(a,7500 ether,_referral,2); \r\n            }\r\n            else if(user[_referral].userIncome + user[_referral].TeamIncome \u003e= 2500 ether)   \r\n            {\r\n                checkcondition(a,2500 ether,_referral,1); \r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n"},"IERC20.sol":{"content":"// SPDX-License-Identifier: GPLv3\r\npragma solidity ^0.8.0;\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}"},"ReentrancyGuard.sol":{"content":"// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot\u0027s contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler\u0027s defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction\u0027s gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and making it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        _nonReentrantBefore();\r\n        _;\r\n        _nonReentrantAfter();\r\n    }\r\n\r\n    function _nonReentrantBefore() private {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n    }\r\n\r\n    function _nonReentrantAfter() private {\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}"},"SafeMath.sol":{"content":"// SPDX-License-Identifier: GPLv3\r\npragma solidity ^0.8.0;\r\n\r\n\r\nlibrary SafeMath {\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c \u003e= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b \u003c= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b \u003e 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n     \r\n    function ceil(uint256 a, uint256 m) internal pure returns (uint256) {\r\n        uint256 c = add(a,m);\r\n        uint256 d = sub(c,1);\r\n        return mul(div(d,m),m);\r\n    }\r\n    \r\n}"}}