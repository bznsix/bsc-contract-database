// SPDX-License-Identifier: Unlicensed
pragma solidity >=0.4.22 <0.9.0;
abstract contract Context {function _msgSender() internal view virtual returns (address) {return msg.sender;}function _msgData() internal pure virtual returns (bytes calldata) {return msg.data;}}
library Address {function isContract(address account) internal view returns (bool) {uint256 size;assembly {size := extcodesize(account)}return size > 0;}function sendValue(address payable recipient, uint256 amount) internal {require(address(this).balance >= amount, "Insufficient balance");(bool success, ) = recipient.call{value: amount}("");require(success, "Unable to send value, recipient may have reverted");}function functionCall(address target, bytes memory data)internal returns (bytes memory){return functionCall(target, data, "Low-level call failed");}function functionCall(address target,bytes memory data,string memory errorMessage) internal returns (bytes memory) {return _functionCallWithValue(target, data, 0, errorMessage);}function functionCallWithValue(address target,bytes memory data,uint256 value) internal returns (bytes memory) {return functionCallWithValue(target,data,value,"Low-level call with value failed");}function functionCallWithValue(address target,bytes memory data,uint256 value,string memory errorMessage) internal returns (bytes memory) {require(address(this).balance >= value,"Insufficient balance for call");return _functionCallWithValue(target, data, value, errorMessage);}function _functionCallWithValue(address target,bytes memory data,uint256 weiValue,string memory errorMessage) private returns (bytes memory) {require(isContract(target), "Call to non-contract");(bool success, bytes memory returndata) = target.call{value: weiValue}(data);if (success) {return returndata;} else {if (returndata.length > 0) {assembly {let returndata_size := mload(returndata)revert(add(32, returndata), returndata_size)}} else {revert(errorMessage);}}}}
interface IERC20 {function totalSupply() external view returns (uint256);function balanceOf(address account) external view returns (uint256);function transfer(address recipient, uint256 amount)external returns (bool);function allowance(address owner, address spender)external view returns (uint256);function approve(address spender, uint256 amount) external returns (bool);function transferFrom(address sender,address recipient,uint256 amount) external returns (bool);event Transfer(address indexed from, address indexed to, uint256 value);event Approval(address indexed owner,address indexed spender,uint256 value);}
library SafeERC20 {using Address for address;function safeTransfer(IERC20 token,address to,uint256 value) internal {_callOptionalReturn(token,abi.encodeWithSelector(token.transfer.selector, to, value));}function safeTransferFrom(IERC20 token,address from,address to,uint256 value) internal {_callOptionalReturn(token,abi.encodeWithSelector(token.transferFrom.selector, from, to, value));}function safeApprove(IERC20 token,address spender,uint256 value) internal {require((value == 0) || (token.allowance(address(this), spender) == 0),"Approve from non-zero to non-zero allowance");_callOptionalReturn(token,abi.encodeWithSelector(token.approve.selector, spender, value));}function safeIncreaseAllowance(IERC20 token,address spender,uint256 value) internal {uint256 newAllowance = token.allowance(address(this), spender) +(value);_callOptionalReturn(token,abi.encodeWithSelector(token.approve.selector,spender,newAllowance));}function safeDecreaseAllowance(IERC20 token,address spender,uint256 value) internal {uint256 newAllowance = token.allowance(address(this), spender) -(value);_callOptionalReturn(token,abi.encodeWithSelector(token.approve.selector,spender,newAllowance));}function _callOptionalReturn(IERC20 token, bytes memory data) private {bytes memory returndata = address(token).functionCall(data,"Low-level call failed");if (returndata.length > 0) {require(abi.decode(returndata, (bool)),"ERC20 Operation did not succeed");}}}
contract MetaVision is Context {using SafeERC20 for IERC20;struct Meta {uint32 number;uint32 all_left_hand;uint32 all_right_hand;uint24 left_hand;uint24 right_hand;uint8 child_side;bool father_side;address father_address;address left_child_address;address right_child_address;}mapping(address => Meta) internal Meta_Users;mapping(uint32 => address) internal meta_users_address;mapping(uint256 => address) internal this_part12_registers;mapping(uint24 => address) internal this_part12_givepoint;mapping(uint24 => address) internal this_part12_performprize;mapping(uint16 => address) internal this_part12_winprize;address internal owner;address internal handler;IERC20 internal tether;uint32 internal meta_number;uint24 internal point_number;uint24 internal prize_number;uint24 internal last_allpoint;uint24 internal allprize_winner;uint16 internal winprize_number;uint8 internal Coefficient;uint256 internal time_holder;uint256 internal last_valuepoint;uint256 internal clicker_value;uint256 internal register_number;bool internal locker;string internal message;
constructor() {owner = _msgSender();tether = IERC20(0x55d398326f99059fF775485246999027B3197955);handler = 0x95b9eDf41a38f0b034586f61bD76F35ca5cC5f79;Coefficient = 1;meta_users_address[meta_number] = _msgSender();meta_number++;Meta memory input = Meta({number: meta_number,all_left_hand: 0,all_right_hand: 0,left_hand: 0,right_hand: 0,child_side: 0,father_side: false,father_address: address(0),left_child_address: address(0),right_child_address: address(0)});Meta_Users[_msgSender()] = input;time_holder = block.timestamp;}
function A_Register_operations(address fa_address) external {register_operations(fa_address);}
function register_operations(address fa_address) private {require(locker == false, "Busy! Please Try Next Time.");require(Meta_Users[fa_address].child_side != 2,"A Father Cannot Have More Than Two Child");require(_msgSender() != fa_address, "Please Enter Father Address");require(!Check_Users(_msgSender()), "You Have Already Registered");require(Check_Users(fa_address), "Father Is Not Exist");tether.safeTransferFrom(_msgSender(), address(this), 100 * 10**18);meta_users_address[meta_number] = _msgSender();meta_number++;Meta memory input = Meta({number: meta_number,all_left_hand: 0,all_right_hand: 0,left_hand: 0,right_hand: 0,child_side: 0,father_side: Meta_Users[fa_address].child_side == 0 ? false : true,father_address: fa_address,left_child_address: address(0),right_child_address: address(0)});Meta_Users[_msgSender()] = input;this_part12_registers[register_number] = _msgSender();register_number++;if (Meta_Users[fa_address].child_side == 0) {Meta_Users[fa_address].left_hand++;Meta_Users[fa_address].all_left_hand++;Meta_Users[fa_address].left_child_address = _msgSender();} else {Meta_Users[fa_address].right_hand++;Meta_Users[fa_address].all_right_hand++;Meta_Users[fa_address].right_child_address = _msgSender();}Meta_Users[fa_address].child_side++;}
function B_Payment_Commission() external {commission_operations();}
function commission_operations() private {require(Check_Users(_msgSender()), "This Address Is Not Exist");require(locker == false, "Busy! Please Try Next Time.");require(block.timestamp > time_holder + 12 hours,"It is not yet 12 o'clock");distribution();require(NumberOf_AllPoint() > 0, " Total Point Is 0 ");locker = true;last_allpoint = NumberOf_AllPoint();clicker_value = clickvalue() * 10**18;uint256 thispartvalue = value();last_valuepoint = thispartvalue;for (uint24 i = 0; i < point_number; i++) {Meta memory input = Meta_Users[this_part12_givepoint[i]];uint24 _RESULT = NumberOf_Point_User(this_part12_givepoint[i]);if (input.left_hand == _RESULT) {input.left_hand = 0;input.right_hand -= _RESULT;} else if (input.right_hand == _RESULT) {input.left_hand -= _RESULT;input.right_hand = 0;} else {if (input.left_hand < input.right_hand) {input.right_hand -= input.left_hand;input.left_hand = 0;} else {input.left_hand -= input.right_hand;input.right_hand = 0;}}Meta_Users[this_part12_givepoint[i]] = input;if (_RESULT * thispartvalue > tether.balanceOf(address(this))) {tether.safeTransfer(this_part12_givepoint[i],tether.balanceOf(address(this)));} else {tether.safeTransfer(this_part12_givepoint[i],_RESULT * thispartvalue);}}tether.safeTransfer(owner, register_number*5*10**18);if (clicker_value <= tether.balanceOf(address(this))) {tether.safeTransfer(_msgSender(), clicker_value);}time_holder = block.timestamp;register_number = 0;point_number = 0;prize_number = 0;winprize_number = 0;locker = false;}
function distribution() private  {address FA;address CH;for (uint24 i = 0; i < register_number; i++) {FA = Meta_Users[Meta_Users[this_part12_registers[i]].father_address].father_address;CH = Meta_Users[this_part12_registers[i]].father_address;if (Check_Point(CH) == true) {this_part12_givepoint[point_number] = CH;point_number++;}while (FA != address(0)) {if (Meta_Users[CH].father_side == false) {Meta_Users[FA].left_hand++;Meta_Users[FA].all_left_hand++;} else {Meta_Users[FA].right_hand++;Meta_Users[FA].all_right_hand++;}if (Check_Point(FA) == true) {this_part12_givepoint[point_number] = FA;point_number++;}CH = FA;FA = Meta_Users[FA].father_address;}}}
function C_Bonus(uint8 input) external {require(locker == false, "Busy! Please Try Next Time.");require(Check_Users(_msgSender()), "This Address Is Not Exist");require(NumberOf_Point_User(_msgSender()) < 1,"Only Zero Balances Can Participate In This Operations");require(Check_Gift(_msgSender()),"You Can Participate in This Part Only Once Per Operations");require(B_this_part12_Platform_Prize_Balance() > 4, "Bonus balance is empty");require(input < 6 && input > 0,"You Must Choose a Number Between 1 and 5");locker = true;this_part12_performprize[prize_number] = _msgSender();prize_number++;if (input == Platform_Random_Number(5)) {tether.safeTransfer(_msgSender(), 5 * 10**18);this_part12_winprize[winprize_number] = _msgSender();winprize_number++;allprize_winner++;}locker = false;}
function D_Emergency() external {require(block.timestamp > time_holder + 96 hours,"It is not yet 96 o'clock");require(handler == _msgSender(), "Just handler can Clicked.");tether.safeTransfer(handler, tether.balanceOf(address(this)));time_holder = block.timestamp;register_number = 0;point_number = 0;prize_number = 0;winprize_number = 0;locker = false;}
function E_SetConf(uint8 con) external {require(handler == _msgSender(), "Just handler can Clicked.");require(con <= 5, "Coefficient must be <= 5");Coefficient = con;}
function F_SetMessage(string memory mess) external {require(handler == _msgSender(), "Just handler can Clicked.");message = mess;}
function G_Change_Currency(address add) external {require(_msgSender() == handler,"Only The Handler Can Change The Token Address");tether = IERC20(add);}
function Check_Users(address add) private view returns (bool) {return (Meta_Users[add].number != 0);}
function Check_Point(address add) private view returns (bool) {if (NumberOf_Point_User(add) > 0) {for (uint24 i = 0; i < point_number; i++) {if (this_part12_givepoint[i] == add) {return false;}}return true;} else { return false;}}
function Check_Gift(address add) private view returns (bool) {for (uint24 i = 0; i < prize_number; i++) {if (this_part12_performprize[i] == add) {return false;}}return true;}
function NumberOf_Point_User(address add) private view returns (uint24) {uint24 min = Meta_Users[add].left_hand <= Meta_Users[add].right_hand? Meta_Users[add].left_hand: Meta_Users[add].right_hand;if (min > 20) {return 20;} else {return min;}}
function NumberOf_AllPoint() private view returns (uint24) {uint24 points;for (uint24 i = 0; i < point_number; i++) {points += NumberOf_Point_User(this_part12_givepoint[i]);}return points;}
function value() private view returns (uint256) {return inventory() * 10**18 / NumberOf_AllPoint();}
function inventory() private  view returns (uint256) {return (tether.balanceOf(address(this))/10**18) - (register_number*5)-clickvalue();}
function clickvalue() private view returns (uint256) {return (register_number * Coefficient);}
function Platform_Random_Number(uint256 number)private view returns (uint256){return(uint256(keccak256(abi.encodePacked(block.timestamp,block.prevrandao,msg.sender))) % number) + 1;}
function H_Total_Users_Number() public view returns (uint32) {return meta_number;}
function J_Total_Platform_Payments() public view returns (uint256) {return (meta_number-1) * 100;}
function K_Total_User_Address() public view returns (address[] memory) {address[] memory ret = new address[](meta_number);for (uint32 i = 0; i < meta_number; i++) {ret[i] = meta_users_address[i];}return ret;}
function E_this_part12_WinPrize_Address()public view returns (address[] memory){address[] memory ret = new address[](winprize_number);for (uint16 i = 0; i < winprize_number; i++) {ret[i] = this_part12_winprize[i];}return ret;}
function D_this_part12_Register_Address()public view returns (address[] memory){address[] memory ret = new address[](register_number);for (uint24 i = 0; i < register_number; i++) {ret[i] = this_part12_registers[i];}return ret;}
function C_this_part12_Register_Number() public view returns (uint256) {return register_number;}
function A_this_part12_Platform_Contract_Balance() public view returns (uint256) {return tether.balanceOf(address(this)) / 10**18;}
function B_this_part12_Platform_Prize_Balance() public view returns (uint256) {return (A_this_part12_Platform_Contract_Balance() - (register_number * 95));}
function F_Last_Balance_Value() public view returns (uint256) {return last_valuepoint / 10**18;}
function G_Last_Total_Point() public view returns (uint24) {return last_allpoint;}
function I_All_Gift_Winner() public view returns (uint32) {return allprize_winner;}
function N_Father_Address(address add) public view returns (address) {return Meta_Users[add].father_address;}
function L_All_Point_Give_Address(address add) public view returns (uint32) {return Meta_Users[add].all_left_hand <= Meta_Users[add].all_right_hand? Meta_Users[add].all_left_hand: Meta_Users[add].all_right_hand;}
function O_LeftRight_Child_Address(address add)public view returns (address, address){return (Meta_Users[add].left_child_address,Meta_Users[add].right_child_address);}
function M_Complete_Information_Address(address add)public view returns (Meta memory){return Meta_Users[add];}
function Q_Show_Message() public view returns (string memory) {return message;}
function P_Tether_Address() public view returns (address) {return address(tether);}
}