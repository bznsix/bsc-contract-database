{"PureMintSwap.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./SafeMath.sol\";\r\n\r\n\r\n/*\r\n@dev STATISTICS1 interface are use in staking contract\r\n*/\r\ninterface STATISTICS1 {\r\n       function getBuyToken()external view returns(uint256);\r\n       function getAmtEach(address user)external  view returns(uint256);\r\n       function getTokenRecived(address user)external view returns(uint256);\r\n}\r\n/*\r\n@dev STATISTICS2 interface have implement in this contract for getting sell token records.\r\n*/\r\ninterface STATISTICS2 {\r\n       function getsellToken()external view returns(uint256);\r\n}\r\n\r\ninterface IERC20 {\r\n// IERC20 interface \r\n/*\r\nonly limited standard methods used in this contract\r\n*/\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n\r\n}\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        this; \r\n        return msg.data;\r\n    }\r\n}\r\n\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor() {\r\n        _setOwner(_msgSender());\r\n    }\r\n\r\n    function Owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(Owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _setOwner(address(0));\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _setOwner(newOwner);\r\n    }\r\n\r\n    function _setOwner(address newOwner) private {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n/*\r\n\r\n@dev all the dependency into the same token pair if in case change the token.\r\n\r\n*/\r\ncontract TokenSwap is Ownable,STATISTICS2 {\r\n    uint256 public sponsorPercentage = 2;\r\n    uint256 public developerPercentage = 5;\r\n    using SafeMath for uint256;\r\n    uint256 private key;\r\n    address public developer;\r\n    address public owner;\r\n    uint256 public flag;\r\n    uint256 private sellToken;\r\n    address public tokenAddress;  // Address of your token contract\r\n    address public stakingAdr;\r\n    address public usdtAddress;   // Address of the USDT contract\r\n\r\n    \r\n       // Exchange rate between your token and USDT\r\n    uint256 public constant DECIMALS = 18; \r\n    uint256 public constant STARTING_PRICE = 20 * (10**DECIMALS); \r\n    struct _u_pdator{\r\n        uint256 update;\r\n        uint256 swaptoken;\r\n    }\r\n    mapping(address =\u003e _u_pdator)private lastupdate;\r\n \r\n    constructor(address _tokenAddress, address _usdtAddress) {\r\n        tokenAddress = _tokenAddress;\r\n        usdtAddress = _usdtAddress;\r\n    }\r\n\r\n\r\n    function getExchangeRate() internal view returns (uint256) {\r\n        uint256 netTokens = STATISTICS1(stakingAdr).getBuyToken() - getsellToken();\r\n        uint256 priceChange = (netTokens * 1 * (10**DECIMALS)) / (20000 * (10**DECIMALS));\r\n        uint256 currentPrice = STARTING_PRICE + priceChange; \r\n        \r\n        return currentPrice/10**2;\r\n    }\r\n    function getsellToken()public  view override returns(uint256){\r\n        return sellToken;\r\n    }\r\n    function setUserLimit(address user)public view returns(uint256){\r\n       return (STATISTICS1(stakingAdr).getAmtEach(user)*10)/100;\r\n    }\r\n    /*\r\n    @dev max amount to swap token each user,\r\n    *fetch the value or amt into the rewards/staking token\r\n    */\r\n    function maxSwap(address user) public view returns(uint256){\r\n     if(STATISTICS1(stakingAdr).getTokenRecived(user) \u003c lastupdate[user].swaptoken){\r\n        return 0;\r\n     }\r\n     else return STATISTICS1(stakingAdr).getTokenRecived(user) - lastupdate[user].swaptoken;\r\n    }\r\n\r\n/*@dev this method only for limited user who are the participant for staking program*/\r\n    function swapTokens(uint256 _amount) external  {  \r\n        require(_amount \u003e 0, \"Token amount must be greater than 0\");\r\n        require(block.timestamp-lastupdate[msg.sender].update \u003e= 1 days ,\"You swap token at a time in a day\");\r\n        require(maxSwap(msg.sender) \u003e= _amount,\"you can not swap more than claimable token\");\r\n        lastupdate[msg.sender].swaptoken +=  _amount;\r\n        lastupdate[msg.sender].update = block.timestamp;\r\n        IERC20 token = IERC20(tokenAddress);\r\n        IERC20 usdt = IERC20(usdtAddress);\r\n        require(token.transferFrom(_msgSender(), address(this), _amount), \"Token transfer failed\");\r\n        uint256 usdtAmT = (_amount * getExchangeRate()) / (10**DECIMALS);\r\n        sellToken += usdtAmT;\r\n        require(usdtAmT \u003c=setUserLimit(msg.sender) ,\u0027You reach the limit\u0027);\r\n        uint256 developerReward = (usdtAmT.mul(developerPercentage)).div(100);\r\n        uint256 usdtAmount = usdtAmT - developerReward;\r\n        require(usdt.transfer(_msgSender(), usdtAmount), \"USDT transfer failed\");\r\n        require(usdt.transfer(developer,developerReward), \"USDT transfer failed\");\r\n    }   \r\n\r\n\r\n\r\n    /*Setter methods are only change by the owner*/\r\n    function RescueAmountoken(address reciver, uint256 amount)external onlyOwner{\r\n        IERC20 token = IERC20(tokenAddress);\r\n        require(amount \u003c= token.balanceOf(address(this)),\"please enter valid amount\");\r\n        require(token.transfer(reciver, amount),\"transaction failed\");\r\n    }\r\n\r\n    function _RescueAmountusdt(address reciver, uint256 amount)external onlyOwner{\r\n        IERC20 token = IERC20(usdtAddress);\r\n        require(amount \u003c= token.balanceOf(address(this)),\"please enter valid amount\");\r\n        require(token.transfer(reciver, amount),\"transaction failed\");\r\n    }\r\n    function setSTaking(address adr)public onlyOwner{\r\n        stakingAdr = adr;\r\n    }\r\n     \r\n\r\n    function setusdtAddress(address _address)external onlyOwner{\r\n        usdtAddress = _address;\r\n    }\r\n\r\n    \r\n    function setTokenAddress(address _address)external onlyOwner{\r\n        tokenAddress = _address;\r\n    }\r\n\r\n\r\n    function setDeveloperAddress(address developerAddress)external  onlyOwner{\r\n        developer = developerAddress;\r\n    }\r\n    \r\n        function setDeveloperRate(uint256 pr)external  onlyOwner{\r\n        developerPercentage = pr;\r\n    }\r\n\r\n    function setUserSwap(address user,uint256 amt)public onlyOwner{\r\n       lastupdate[user].swaptoken = amt; \r\n    }\r\n\r\n}\r\n\r\n"},"SafeMath.sol":{"content":"// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n// CAUTION\r\n// This version of SafeMath should only be used with Solidity 0.8 or later,\r\n// because it relies on the compiler\u0027s built in overflow checks.\r\n\r\n/**\r\n * @dev Wrappers over Solidity\u0027s arithmetic operations.\r\n *\r\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\r\n * now has built in overflow checking.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            uint256 c = a + b;\r\n            if (c \u003c a) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b \u003e a) return (false, 0);\r\n            return (true, a - b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\r\n            // benefit is lost if \u0027b\u0027 is also tested.\r\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n            if (a == 0) return (true, 0);\r\n            uint256 c = a * b;\r\n            if (c / a != b) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a / b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a % b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity\u0027s `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a + b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity\u0027s `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity\u0027s `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a * b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s `/` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a % b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {trySub}.\r\n     *\r\n     * Counterpart to Solidity\u0027s `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b \u003c= a, errorMessage);\r\n            return a - b;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b \u003e 0, errorMessage);\r\n            return a / b;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting with custom message when dividing by zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryMod}.\r\n     *\r\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b \u003e 0, errorMessage);\r\n            return a % b;\r\n        }\r\n    }\r\n}"}}