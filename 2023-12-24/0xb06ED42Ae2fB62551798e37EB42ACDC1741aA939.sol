// SPDX-License-Identifier: MIT
//
// Wrapped(copy) version of the Vertex Chain Coin- in BSC
// We will try our best to make stable change of: 1 VRX(vertex blockchain) = 1 VRX(BSC blockchain)
// We do not We do not guarantee stability of the token, all risks by using this token- is your risks!
// Project by Krasavchik and Dapshen.
//
//
// Telegram Bot of Vertex: https://t.me/BoosterMoneyBot?start=1133335322
// All links: https://linktr.ee/vertexchain
//
//
// Krasavchik- sponsor and referals MLM structure inviter(chat- https://t.me/jessidesigner)
// Dapshen- programmist and idea!(Channel- https://t.me/profitnee / https://www.youtube.com/@D_CR)
//                           _                     _                  _
//  ___ _ __ ___   __ _ _ __| |_    ___ ___  _ __ | |_ _ __ __ _  ___| |_
// / __| '_ ` _ \ / _` | '__| __|  / __/ _ \| '_ \| __| '__/ _` |/ __| __|
// \__ \ | | | | | (_| | |  | |_  | (_| (_) | | | | |_| | | (_| | (__| |_
// |___/_| |_| |_|\__,_|_|   \__|  \___\___/|_| |_|\__|_|  \__,_|\___|\__|
//
//
// █       █
// █       █
// █       █
//  █     █
//  █     █     ███   █  █     █       ███   █    █
//  █     █    █   █  █ █      █      █   █   █  █
//   █   █    █    █  ██    ███████  █    █    ██
//   █   █    █████   █        █     █████     ██
//    █ █      █      █        █      █       █  █
//     █        ████  █        █       ████  █    █
//
//
// ▓▓▓▓▓▓                                      ▓▓▓▓
// ▓                                         ▓▓    ▓▓
// ▓                                        ▓        ▓
// ▓                                         ▓▓
// ▓▓▓▓▓▓  ▓  ▓    ▓    ▓▓▓        ▓           ▓▓          ▓        ▓▓▓  ▓   ▓   ▓  ▓  ▓  ▓▓     ▓▓▓▓
// ▓           ▓  ▓    ▓   ▓       ▓             ▓▓        ▓      ▓▓   ▓ ▓   ▓  ▓      ▓ ▓  ▓   ▓    ▓
// ▓       ▓    ▓▓    ▓    ▓  ▓▓▓▓▓▓               ▓▓   ▓▓▓▓▓▓▓  ▓      ▓    ▓▓▓    ▓  ▓▓    ▓  ▓    ▓
// ▓       ▓    ▓▓    ▓▓▓▓▓   ▓    ▓        ▓        ▓     ▓     ▓      ▓    ▓ ▓    ▓  ▓     ▓   ▓▓▓▓▓
// ▓       ▓   ▓  ▓    ▓      ▓    ▓         ▓▓    ▓▓      ▓      ▓▓   ▓ ▓   ▓  ▓   ▓  ▓     ▓       ▓
// ▓       ▓  ▓    ▓    ▓▓▓▓  ▓▓▓▓▓▓           ▓▓▓▓        ▓        ▓▓▓   ▓  ▓   ▓  ▓  ▓     ▓   ▓▓▓▓
//
//
// ▒▒▒▒▒▒▒▒▒▒                        ▒▒▒▒▒▒                                                ▒▒▒▒▒
//     ▒▒                            ▒     ▒                                                 ▒
//     ▒▒                            ▒      ▒                                                ▒
//     ▒▒                            ▒      ▒                                                ▒
//     ▒▒      ▒         ▒▒▒         ▒     ▒      ▒▒▒     ▒         ▒    ▒▒▒   ▒  ▒          ▒     ▒▒▒▒
//     ▒▒      ▒        ▒   ▒        ▒▒▒▒▒▒     ▒▒   ▒▒   ▒    ▒    ▒   ▒   ▒  ▒ ▒           ▒    ▒    ▒
//     ▒▒      ▒ ▒▒▒   ▒    ▒        ▒         ▒       ▒   ▒   ▒   ▒   ▒    ▒  ▒▒            ▒     ▒▒
//     ▒▒      ▒▒   ▒  ▒▒▒▒▒         ▒         ▒       ▒   ▒   ▒   ▒   ▒▒▒▒▒   ▒             ▒       ▒▒
//     ▒▒      ▒    ▒   ▒            ▒          ▒▒   ▒▒     ▒ ▒ ▒ ▒     ▒      ▒             ▒    ▒    ▒
//     ▒▒      ▒    ▒    ▒▒▒▒        ▒            ▒▒▒        ▒   ▒       ▒▒▒▒  ▒           ▒▒▒▒▒   ▒▒▒▒
//
//
// ▒▒▒▒▒                 ▒▒▒▒▒▒▒▒▒▒                        ▒▒▒▒▒▒▒▒▒▒
//   ▒                       ▒▒                                ▒▒
//   ▒                       ▒▒                                ▒▒
//   ▒                       ▒▒                                ▒▒
//   ▒    ▒  ▒▒              ▒▒      ▒         ▒▒▒             ▒▒      ▒  ▒  ▒     ▒       ▒     ▒
//   ▒    ▒ ▒  ▒             ▒▒      ▒        ▒   ▒            ▒▒      ▒ ▒   ▒     ▒       ▒     ▒
//   ▒    ▒▒    ▒            ▒▒      ▒ ▒▒▒   ▒    ▒            ▒▒      ▒▒    ▒     ▒    ▒▒▒▒▒▒▒  ▒ ▒▒▒
//   ▒    ▒     ▒            ▒▒      ▒▒   ▒  ▒▒▒▒▒             ▒▒      ▒     ▒     ▒       ▒     ▒▒   ▒
//   ▒    ▒     ▒            ▒▒      ▒    ▒   ▒                ▒▒      ▒      ▒   ▒ ▒      ▒     ▒    ▒
// ▒▒▒▒▒  ▒     ▒            ▒▒      ▒    ▒    ▒▒▒▒            ▒▒      ▒       ▒▒▒   ▒     ▒     ▒    ▒
//
//
// Smart-contract code used here is the Rimer Finance Fork!
// Want token like this or want to write to the programmist?- here are the contacts:
// Programmist- https://t.me/Da_pshen ; Rimer Finance- https://t.me/Rimer_Finance_RU

pragma solidity ^0.8.0;

interface IERC20 {
  function totalSupply() external view returns (uint256);

  function balanceOf(address account) external view returns (uint256);

  function transfer(address recipient, uint256 amount)
  external
  returns (bool);

  function allowance(address owner, address spender)
  external
  view
  returns (uint256);

  function approve(address spender, uint256 amount) external returns (bool);

  function transferFrom(
    address sender,
    address recipient,
    uint256 amount
  ) external returns (bool);

  event Claim(address indexed owner, uint256 value);
  event Transfer(address indexed from, address indexed to, uint256 value);
  event Approval(
    address indexed owner,
    address indexed spender,
    uint256 value
  );
}

library SafeMath {
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    require(c >= a, "SafeMath: addition overflow");
    return c;
  }

  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    require(b <= a, "SafeMath: subtraction overflow");
    uint256 c = a - b;
    return c;
  }

  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    require(c / a == b, "SafeMath: multiplication overflow");
    return c;
  }

  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    require(b > 0, "SafeMath: division by zero");
    uint256 c = a / b;
    return c;
  }
}

contract VertexChain is IERC20 {
  using SafeMath for uint256;

  string private _name = "Vertex Coin(Wrapped in BSC)";
  string private _symbol = "VRX";
  uint8 private _decimals = 18;
  uint256 private _totalSupply = 100000 * 10**uint256(_decimals);

  mapping(address => uint256) private _balances;
  mapping(address => mapping(address => uint256)) private _allowances;

  // Variables for fee and reward
  uint256 public transactionFee = 5;
  
  uint256 public stackingPercentage = 10;
  uint256 public stakingInterval = 1 hours;
  mapping(address => uint256) public stackingBalance;
  mapping(address => uint256) public lastClaimTimestamp;
  
  mapping(address => uint256) private _excludeAddress;
  address[] public allHolders;

  address public _owner;
  address public _burnAddress;



  constructor() {
    _balances[msg.sender] = _totalSupply;
    _owner = msg.sender;
    _burnAddress = address(0);
    lastClaimTimestamp[_owner] = block.timestamp;
    allHolders.push(_owner);
    emit Transfer(address(0), msg.sender, _totalSupply);
  }

  function name() public view returns (string memory) {
    return _name;
  }

  function symbol() public view returns (string memory) {
    return _symbol;
  }

  function decimals() public view returns (uint8) {
    return _decimals;
  }

  function totalSupply() public view override returns (uint256) {
    return _totalSupply;
  }

  function balanceOf(address account) public view override returns (uint256) {
    return _balances[account];
  }

  function transfer(address recipient, uint256 amount) public override returns (bool) {
    _transfer(msg.sender, recipient, amount);
    return true;
  }

  function allowance(address owner, address spender) public view override returns (uint256) {
    return _allowances[owner][spender];
  }

  function approve(address spender, uint256 amount) public override returns (bool) {
    _approve(msg.sender, spender, amount);
    return true;
  }

  function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {
    _transfer(sender, recipient, amount);
    _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));
    return true;
  }

  function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
    _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));
    return true;
  }

  function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
    _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));
    return true;
  }

  function getHoursElapsed(address user) public view returns (uint256)  {
    if(lastClaimTimestamp[user] == 0) return 0;
    return block.timestamp.sub(lastClaimTimestamp[user]).div(stakingInterval);
  }

  function getRewardPerHour(address user) public view returns (uint256)  {
    if(lastClaimTimestamp[user] == 0) return 0;
    return stackingBalance[user].mul(stackingPercentage).div(100000);
  }

  function depositToStaking(uint256 amount) 
  public returns(bool) {
    address user = msg.sender;
    require(amount >= 10**18*10, "Deposit amount must be multiple of 10 VRX");
    require(amount <= _balances[user], "not enoght tokens");
    claimHolderRewards(user);
    _balances[user] = _balances[user].sub(amount);  
    stackingBalance[user]=stackingBalance[user].add(amount);
    if (lastClaimTimestamp[user] == 0){
      allHolders.push(user);
      lastClaimTimestamp[user] = block.timestamp;
    }
    return true;
  }

  function withdrawFromStaking(uint256 amount) 
  public returns(bool) {
    address user = msg.sender;
    require(amount >= stackingBalance[user], "not enoght tokens");
    claimHolderRewards(user);
    stackingBalance[user]=stackingBalance[user].sub(amount);
    _balances[user] = _balances[user].add(amount);   
    return true;
  }

  function claimRewards() 
  public {
    address user = msg.sender;
    claimHolderRewards(user);
  }

  function calcRewards(address user) public view returns(uint256) {
    require(stackingBalance[user] > 0, "user has no rewards");
    return getHoursElapsed(user).mul(getRewardPerHour(user));
  }

  function updateTransactionFee(uint256 fee) public onlyOwner {
    require(fee >= 0 && fee <= 20, "Transaction fee: Invalid value");
    transactionFee = fee;
  }

  function updateRewardPercentage(uint256 percentage) public onlyOwner {
    require(percentage >= 1 && percentage <= 100, "Invalid value");
    for (uint i = 0; i < allHolders.length; i++) {
      claimHolderRewards(allHolders[i]);
    }
    stackingPercentage = percentage;
  }

  function claimHolderRewards(address user) internal {
    
    if(stackingBalance[user] > 0){

      uint256 rewardPerHour = getRewardPerHour(user);
      uint256 hoursElapsed = getHoursElapsed(user);

      uint256 reward = hoursElapsed.mul(rewardPerHour);
      
      lastClaimTimestamp[user] =lastClaimTimestamp[user].add(hoursElapsed.mul(stakingInterval));
      _totalSupply = _totalSupply.add(reward);

      _balances[user] = _balances[user].add(reward);
      emit Claim(user, reward);
    }
  }

  function addExcludeAddress(address exAddress)
  public onlyOwner {
    _excludeAddress[exAddress] = 1;
  }

  function removeExcludeAddress(address exAddress)
  public onlyOwner {
    _excludeAddress[exAddress] = 0;
  }

  function statusExcludeAddress(address exAddress)
  public view returns (bool) {
    if (_excludeAddress[exAddress] == 1)
      return true;
    return false;
  }

  function transferOwnership(address newOwner) public onlyOwner {
    require(newOwner != address(0), "Ownership: New owner is the zero address");
    _owner = newOwner;
  }

  function _transfer(address sender, address recipient, uint256 amount) internal {
    require(sender != address(0), "Transfer: Transfer from the zero address");
    require(recipient != address(0), "Transfer: Transfer to the zero address");
    require(amount > 0, "Transfer: Transfer amount must be greater than zero");
    require(_balances[sender] >= amount, "Transfer: Insufficient balance");

    uint256 transferAmount = amount;

    if (_excludeAddress[sender] == 0 && _excludeAddress[recipient] == 0) {
      uint256 fee = amount.mul(transactionFee).div(100);
      transferAmount = amount.sub(fee);
      _burn(sender, fee);
    }

    _balances[sender] = _balances[sender].sub(transferAmount);
    _balances[recipient] = _balances[recipient].add(transferAmount);

    if (lastClaimTimestamp[recipient] == 0){
      allHolders.push(recipient);
      lastClaimTimestamp[recipient] = block.timestamp;
    }
    emit Transfer(sender, recipient, transferAmount);
  }

  function _burn(address account, uint256 amount) internal {
    require(account != address(0), "Burn: Burn from the zero address");
    require(amount > 0, "Burn: Burn amount must be greater than zero");
    require(_balances[account] >= amount, "Burn: Insufficient balance");

    _balances[account] = _balances[account].sub(amount);

    _balances[_burnAddress] = _balances[_burnAddress].add(amount);

    _totalSupply = _totalSupply.sub(amount);

    emit Transfer(account, _burnAddress, amount);
  }

  function _approve(address owner, address spender, uint256 amount) internal {
    require(owner != address(0), "Approve: Approve from the zero address");
    require(spender != address(0), "Approve: Approve to the zero address");

    _allowances[owner][spender] = amount;
    emit Approval(owner, spender, amount);
  }

  modifier onlyOwner() {
    require(msg.sender == _owner, "Only Owner: Caller is not the owner");
    _;
  }
}