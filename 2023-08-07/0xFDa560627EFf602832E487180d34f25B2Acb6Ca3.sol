{"TokenManager.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\n\npragma solidity \u003e=0.8.0 \u003c0.9.0;\n\ninterface ERC20 {\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n}\n\nstruct Token\n{\n    address tokenContract;\n    string symbol;\n    string name;\n    uint decimals;\n}\n\nlibrary Custom_ERC20 {\n\n    function ETH() internal pure returns (Token memory)\n    {\n        return Token({\n            tokenContract: 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE,\n            symbol: \"ETH\",\n            name: \"ETH\",\n            decimals: 18\n        });\n    }\n}\n\nlibrary TokenHelper {\n    function get(address _tokenContract) internal view returns (Token memory)\n    {\n        if (_tokenContract == Custom_ERC20.ETH().tokenContract)\n        {\n            return Custom_ERC20.ETH();\n        }\n        else\n        {\n            ERC20 erc20 = ERC20(_tokenContract);\n            require(erc20.decimals() \u003c= 18, \"This decimal is not supported\");\n\n            return Token({\n                    tokenContract: _tokenContract,\n                    symbol:erc20.symbol(),\n                    name:erc20.name(),\n                    decimals:erc20.decimals()\n                });\n        }\n    }\n}\n\nstruct TokenMap\n{\n    mapping(address =\u003e Token) data;\n    address[] keys;\n    uint size;\n}\n\nlibrary TokenMapHelper {\n\n    function insert(TokenMap storage tokenMap, address __tokenContract) internal returns (bool)\n    {\n        if (tokenMap.data[__tokenContract].tokenContract != address(0))\n            return false;\n        else\n        {\n            Token memory token = TokenHelper.get(__tokenContract);\n            tokenMap.data[__tokenContract] = Token(__tokenContract, token.symbol, token.name, token.decimals);\n            tokenMap.size++;\n            {\n                bool added = false;\n                for (uint i=0; i\u003ctokenMap.keys.length;i++)\n                {\n                    if (tokenMap.keys[i] == address(0))\n                    {\n                        tokenMap.keys[i] = __tokenContract;\n                        added = true;\n                        break;\n                    }\n                }\n                if (added == false)\n                {\n                    tokenMap.keys.push(__tokenContract);\n                }\n            }\n            return true;\n        }\n     }\n\n    function remove(TokenMap storage tokenMap, address __tokenContract) internal returns (bool)\n    {\n        if (tokenMap.data[__tokenContract].tokenContract == address(0))\n            return false;\n        else\n        {\n            delete tokenMap.data[__tokenContract];\n            tokenMap.size--;\n\n            for (uint i=0; i\u003ctokenMap.keys.length; i++)\n            {\n                if (tokenMap.keys[i] == __tokenContract)\n                {\n                    tokenMap.keys[i] = address(0);\n                }\n            }\n\n            while (true)\n            {\n                if (tokenMap.keys.length == 0)\n                    break;\n                if (tokenMap.keys[tokenMap.keys.length-1] != address(0))\n                    break;\n                tokenMap.keys.pop();\n            }\n\n            return true;\n        }\n    }\n\n    function get(TokenMap storage tokenMap, address __tokenContract) internal view returns (Token memory)\n    {\n        return tokenMap.data[__tokenContract];\n    }\n\n    function length(TokenMap storage tokenMap) internal view returns (uint256)\n    {\n        return tokenMap.keys.length;\n    }\n\n    function toList(TokenMap storage tokenMap, uint256 start, uint256 end) internal view returns (address[] memory list)\n    {\n        end = tokenMap.keys.length \u003e= end ? end : tokenMap.keys.length;\n        list = new address[](end-start);\n        uint index = 0;\n        for (uint256 i=start; i\u003cend; i++)\n        {\n            list[index] = tokenMap.keys[i];\n            index++;\n        }\n        return list;\n    }\n}\n\ncontract TokenManager {\n\n    // 交易对\n    TokenMap tokenMap;\n\n    address private _owner;\n    mapping (address =\u003e bool) private _admins;\n\n    event Insert(address indexed token, bytes symbol, bytes name, uint decimals);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () {\n        _owner = msg.sender;\n    }\n\n    function setAdmin(address __admin, bool isTrue) external onlyOwner\n    {\n        _admins[__admin] = isTrue;\n    }\n\n    modifier onlyOwner() {\n        require(_owner == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    modifier onlyAdmin() {\n        require(_admins[msg.sender] == true || _owner == msg.sender, \"Ownable: caller is not the admin\");\n        _;\n    }\n\n    function insertToken(address __token) external onlyAdmin returns (bool)\n    {\n        bool res = TokenMapHelper.insert(tokenMap, __token);\n        if (res)\n        {\n            Token memory t = TokenMapHelper.get(tokenMap, __token);\n            emit Insert(__token, bytes(t.symbol), bytes(t.name), t.decimals);\n        }\n        return res;\n    }\n \n    function getToken(address __tokenContract) external view returns (Token memory)\n    {\n        return TokenMapHelper.get(tokenMap, __tokenContract);\n    }\n}\n\n\n\n\n\n\n\n"},"TokenPairManager.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\n\npragma solidity \u003e=0.8.0 \u003c0.9.0;\n\nimport \"./TokenManager.sol\";\n\ninterface DexController {\n\n    function insertToken(address _usdContract, address _tokenContract) external returns (uint256 pfix);\n}\n\nstruct TokenPair {\n    address dex;\n    address usd;\n    address token;\n}\n\ncontract TokenPairManager {\n\n    uint256 autoIncrement;\n    mapping (uint256 =\u003e TokenPair) tokenPairs;\n    mapping (address =\u003e address) pairings;\n\n    TokenManager tokenManager;\n    address private _owner;\n    mapping (address =\u003e bool) private _admins;\n\n    event Insert(uint256 indexed pairId, address indexed dexContract, address usdContract, address tokenContract, uint256 pfix);\n    event Remove(uint256 indexed pairId, address indexed dexContract, address usdContract, address tokenContract);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () {\n        _owner = msg.sender;\n        tokenManager = new TokenManager();\n    }\n\n    function setAdmin(address __admin, bool isTrue) external onlyOwner\n    {\n        _admins[__admin] = isTrue;\n    }\n\n    modifier onlyOwner() {\n        require(_owner == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    modifier onlyAdmin() {\n        require(_admins[msg.sender] == true || _owner == msg.sender, \"Ownable: caller is not the admin\");\n        _;\n    }\n\n    function getTokenManager() external view returns (address)\n    {\n        return address(tokenManager);\n    }\n\n    function insertTokenPair(address __dexContract, address __usd, address __token) external onlyAdmin returns (bool)\n    {\n        bool res = false;\n        if (pairings[__token] == address(0))\n        {\n            pairings[__token] = __usd;\n            autoIncrement++;\n            tokenPairs[autoIncrement] = TokenPair(__dexContract, __usd, __token);\n            uint256 pfix = DexController(__dexContract).insertToken(__usd, __token);\n            tokenManager.insertToken(__usd);\n            tokenManager.insertToken(__token);\n            emit Insert(autoIncrement, __dexContract, __usd, __token, pfix);\n            res = true;\n        }\n        return res;\n    }\n\n    function removeTokenPair(uint256 pairId) external onlyAdmin returns (bool)\n    {\n        bool res = false;\n        if (tokenPairs[pairId].dex != address(0))\n        {\n            address __dexContract = tokenPairs[pairId].dex;\n            address __usd = tokenPairs[pairId].usd;\n            address __token = tokenPairs[pairId].token;\n            delete pairings[__token];\n            delete tokenPairs[pairId];\n            emit Remove(pairId, __dexContract, __usd, __token);\n        }\n        return res;\n    }\n}\n\n\n\n\n\n\n\n"}}