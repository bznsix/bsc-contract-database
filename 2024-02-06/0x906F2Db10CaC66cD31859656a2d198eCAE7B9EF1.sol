{"BuilderInternal.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./BuilderModifiers.sol\";\nimport \"./ISimpleProvider.sol\";\n\ncontract BuilderInternal is BuilderModifiers {\n    ///@dev if params is empty, then return [amount]\n    function _concatParams(uint amount, uint256[] calldata params) internal pure returns (uint256[] memory result) {\n        uint256 length = params.length;\n        result = new uint256[](length + 1);\n        result[0] = amount;\n        for (uint256 i = 0; i \u003c length; ) {\n            result[i + 1] = params[i];\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function _createNewNFT(\n        ISimpleProvider provider,\n        uint256 tokenPoolId,\n        UserPool memory userData,\n        uint256[] memory params\n    ) internal virtual validUserData(userData) returns (uint256 amount) {\n        amount = userData.amount;\n        uint256 poolId = lockDealNFT.mintForProvider(userData.user, provider);\n        params[0] = userData.amount;\n        provider.registerPool(poolId, params);\n        lockDealNFT.cloneVaultId(poolId, tokenPoolId);\n    }\n\n    function _createFirstNFT(\n        ISimpleProvider provider,\n        address token,\n        address owner,\n        uint256 totalAmount,\n        uint256[] memory params,\n        bytes calldata signature\n    ) internal virtual notZeroAddress(owner) returns (uint256 poolId) {\n        poolId = lockDealNFT.safeMintAndTransfer(owner, token, msg.sender, totalAmount, provider, signature);\n        provider.registerPool(poolId, params);\n    }\n}\n"},"BuilderModifiers.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./ERC165Checker.sol\";\nimport \"./BuilderState.sol\";\n\ncontract BuilderModifiers is BuilderState {\n    modifier notZeroAddress(address _address) {\n        _notZeroAddress(_address);\n        _;\n    }\n    \n    modifier validUserData(UserPool memory userData) {\n        _notZeroAddress(userData.user);\n        _notZeroAmount(userData.amount);\n        _;\n    }\n\n    function _notZeroAmount(uint256 amount) internal pure {\n        require(amount \u003e 0, \"amount must be greater than 0\");\n    }\n\n    function _notZeroAddress(address _address) internal pure {\n        require(_address != address(0x0), \"Zero Address is not allowed\");\n    }\n\n    function _validParamsLength(uint256 paramsLength, uint256 minLength) internal pure {\n        require(paramsLength \u003e= minLength, \"invalid params length\");\n    }\n}\n"},"BuilderState.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./ILockDealNFT.sol\";\n\ncontract BuilderState {\n    ILockDealNFT public lockDealNFT;\n\n    struct Builder {\n        UserPool[] userPools;\n        uint256 totalAmount;\n    }\n\n    struct UserPool {\n        address user;\n        uint256 amount;\n    }\n}\n"},"CalcUtils.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nlibrary CalcUtils {\n    function calcAmount(uint256 amount, uint256 rate) internal pure returns (uint256 tokenA) {\n        return (amount * rate) / 1e21;\n    }\n\n    function calcRate(uint256 tokenAValue, uint256 tokenBValue) internal pure returns (uint256 rate) {\n        return (tokenAValue * 1e21) / tokenBValue;\n    }\n}\n"},"ERC165Checker.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/introspection/ERC165Checker.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Library used to query support of an interface declared via {IERC165}.\n *\n * Note that these functions return the actual result of the query: they do not\n * `revert` if an interface is not supported. It is up to the caller to decide\n * what to do in these cases.\n */\nlibrary ERC165Checker {\n    // As per the EIP-165 spec, no interface should ever match 0xffffffff\n    bytes4 private constant _INTERFACE_ID_INVALID = 0xffffffff;\n\n    /**\n     * @dev Returns true if `account` supports the {IERC165} interface.\n     */\n    function supportsERC165(address account) internal view returns (bool) {\n        // Any contract that implements ERC165 must explicitly indicate support of\n        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid\n        return\n            supportsERC165InterfaceUnchecked(account, type(IERC165).interfaceId) \u0026\u0026\n            !supportsERC165InterfaceUnchecked(account, _INTERFACE_ID_INVALID);\n    }\n\n    /**\n     * @dev Returns true if `account` supports the interface defined by\n     * `interfaceId`. Support for {IERC165} itself is queried automatically.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {\n        // query support of both ERC165 as per the spec and support of _interfaceId\n        return supportsERC165(account) \u0026\u0026 supportsERC165InterfaceUnchecked(account, interfaceId);\n    }\n\n    /**\n     * @dev Returns a boolean array where each value corresponds to the\n     * interfaces passed in and whether they\u0027re supported or not. This allows\n     * you to batch check interfaces for a contract where your expectation\n     * is that some interfaces may not be supported.\n     *\n     * See {IERC165-supportsInterface}.\n     *\n     * _Available since v3.4._\n     */\n    function getSupportedInterfaces(\n        address account,\n        bytes4[] memory interfaceIds\n    ) internal view returns (bool[] memory) {\n        // an array of booleans corresponding to interfaceIds and whether they\u0027re supported or not\n        bool[] memory interfaceIdsSupported = new bool[](interfaceIds.length);\n\n        // query support of ERC165 itself\n        if (supportsERC165(account)) {\n            // query support of each interface in interfaceIds\n            for (uint256 i = 0; i \u003c interfaceIds.length; i++) {\n                interfaceIdsSupported[i] = supportsERC165InterfaceUnchecked(account, interfaceIds[i]);\n            }\n        }\n\n        return interfaceIdsSupported;\n    }\n\n    /**\n     * @dev Returns true if `account` supports all the interfaces defined in\n     * `interfaceIds`. Support for {IERC165} itself is queried automatically.\n     *\n     * Batch-querying can lead to gas savings by skipping repeated checks for\n     * {IERC165} support.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {\n        // query support of ERC165 itself\n        if (!supportsERC165(account)) {\n            return false;\n        }\n\n        // query support of each interface in interfaceIds\n        for (uint256 i = 0; i \u003c interfaceIds.length; i++) {\n            if (!supportsERC165InterfaceUnchecked(account, interfaceIds[i])) {\n                return false;\n            }\n        }\n\n        // all interfaces supported\n        return true;\n    }\n\n    /**\n     * @notice Query if a contract implements an interface, does not check ERC165 support\n     * @param account The address of the contract to query for support of an interface\n     * @param interfaceId The interface identifier, as specified in ERC-165\n     * @return true if the contract at account indicates support of the interface with\n     * identifier interfaceId, false otherwise\n     * @dev Assumes that account contains a contract that supports ERC165, otherwise\n     * the behavior of this method is undefined. This precondition can be checked\n     * with {supportsERC165}.\n     *\n     * Some precompiled contracts will falsely indicate support for a given interface, so caution\n     * should be exercised when using this function.\n     *\n     * Interface identification is specified in ERC-165.\n     */\n    function supportsERC165InterfaceUnchecked(address account, bytes4 interfaceId) internal view returns (bool) {\n        // prepare call\n        bytes memory encodedParams = abi.encodeWithSelector(IERC165.supportsInterface.selector, interfaceId);\n\n        // perform static call\n        bool success;\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly {\n            success := staticcall(30000, account, add(encodedParams, 0x20), mload(encodedParams), 0x00, 0x20)\n            returnSize := returndatasize()\n            returnValue := mload(0x00)\n        }\n\n        return success \u0026\u0026 returnSize \u003e= 0x20 \u0026\u0026 returnValue \u003e 0;\n    }\n}\n"},"ERC721Holder.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/utils/ERC721Holder.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721Receiver.sol\";\n\n/**\n * @dev Implementation of the {IERC721Receiver} interface.\n *\n * Accepts all token transfers.\n * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.\n */\ncontract ERC721Holder is IERC721Receiver {\n    /**\n     * @dev See {IERC721Receiver-onERC721Received}.\n     *\n     * Always returns `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(address, address, uint256, bytes memory) public virtual override returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n}\n"},"FirewallConsumer.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n// See LICENSE file for full license text.\n// Copyright (c) Ironblocks 2023\npragma solidity 0.8.19;\n\nimport \"./FirewallConsumerBase.sol\";\n\n/**\n * @title Firewall Consumer\n * @author David Benchimol @ Ironblocks \n * @dev This contract is a parent contract that can be used to add firewall protection to any contract.\n *\n * The contract must initializes with the firewall contract disabled, and the deployer\n * as the firewall admin.\n *\n */\ncontract FirewallConsumer is FirewallConsumerBase(address(0), msg.sender) {\n}\n"},"FirewallConsumerBase.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n// See LICENSE file for full license text.\n// Copyright (c) Ironblocks 2023\npragma solidity 0.8.19;\n\nimport \"./IFirewall.sol\";\nimport \"./IFirewallConsumer.sol\";\n\n/**\n * @title Firewall Consumer Base Contract\n * @author David Benchimol @ Ironblocks \n * @dev This contract is a parent contract that can be used to add firewall protection to any contract.\n *\n * The contract must define a firewall contract which will manage the policies that are applied to the contract.\n * It also must define a firewall admin which will be able to add and remove policies.\n *\n */\ncontract FirewallConsumerBase is IFirewallConsumer {\n\n    address private firewall;\n    address public firewallAdmin;\n\n    /**\n     * @dev modifier that will run the preExecution and postExecution hooks of the firewall, applying each of\n     * the subscribed policies.\n     */\n    modifier firewallProtected() {\n        if (firewall == address(0)) {\n            _;\n            return;\n        }\n        uint value;\n        // We do this because msg.value can only be accessed in payable functions.\n        assembly {\n            value := callvalue()\n        }\n        IFirewall(firewall).preExecution(msg.sender, msg.data, value);\n        _; \n        IFirewall(firewall).postExecution(msg.sender, msg.data, value);\n    }\n\n    /**\n     * @dev modifier that will run the preExecution and postExecution hooks of the firewall, applying each of\n     * the subscribed policies. Allows passing custom data to the firewall, not necessarily msg.data.\n     * Useful for checking internal function calls\n     */\n    modifier firewallProtectedCustom(bytes memory data) {\n        if (firewall == address(0)) {\n            _;\n            return;\n        }\n        uint value;\n        // We do this because msg.value can only be accessed in payable functions.\n        assembly {\n            value := callvalue()\n        }\n        IFirewall(firewall).preExecution(msg.sender, data, value);\n        _; \n        IFirewall(firewall).postExecution(msg.sender, data, value);\n    }\n\n    /**\n     * @dev identical to the rest of the modifiers in terms of logic, but makes it more\n     * aesthetic when all you want to pass are signatures/unique identifiers.\n     */\n    modifier firewallProtectedSig(bytes4 selector) {\n        if (firewall == address(0)) {\n            _;\n            return;\n        }\n        uint value;\n        // We do this because msg.value can only be accessed in payable functions.\n        assembly {\n            value := callvalue()\n        }\n        IFirewall(firewall).preExecution(msg.sender, abi.encodePacked(selector), value);\n        _; \n        IFirewall(firewall).postExecution(msg.sender, abi.encodePacked(selector), value);\n    }\n\n    /**\n     * @dev modifier similar to onlyOwner, but for the firewall admin.\n     */\n    modifier onlyFirewallAdmin() {\n        require(msg.sender == firewallAdmin, \"FirewallConsumer: not firewall admin\");\n        _;\n    }\n\n    /**\n     * @dev Initializes a contract protected by a firewall, with a firewall address and a firewall admin.\n     */\n    constructor(\n        address _firewall,\n        address _firewallAdmin\n    ) {\n        firewall = _firewall;\n        firewallAdmin = _firewallAdmin;\n    }\n\n    /**\n     * @dev Admin only function allowing the consumers admin to remove a policy from the consumers subscribed policies.\n     */\n    function setFirewall(address _firewall) external onlyFirewallAdmin {\n        firewall = _firewall;\n    }\n\n    /**\n     * @dev Admin only function allowing the consumers admin to remove a policy from the consumers subscribed policies.\n     */\n    function setFirewallAdmin(address _firewallAdmin) external onlyFirewallAdmin {\n        require(_firewallAdmin != address(0), \"FirewallConsumer: zero address\");\n        firewallAdmin = _firewallAdmin;\n    }\n\n}\n"},"IERC165.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"},"IERC2981.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC2981.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Interface for the NFT Royalty Standard.\n *\n * A standardized way to retrieve royalty payment information for non-fungible tokens (NFTs) to enable universal\n * support for royalty payments across all NFT marketplaces and ecosystem participants.\n *\n * _Available since v4.5._\n */\ninterface IERC2981 is IERC165 {\n    /**\n     * @dev Returns how much royalty is owed and to whom, based on a sale price that may be denominated in any unit of\n     * exchange. The royalty amount is denominated and should be paid in that same unit of exchange.\n     */\n    function royaltyInfo(\n        uint256 tokenId,\n        uint256 salePrice\n    ) external view returns (address receiver, uint256 royaltyAmount);\n}\n"},"IERC721.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``\u0027s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"},"IERC721Enumerable.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Enumerable is IERC721 {\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``\u0027s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"},"IERC721Receiver.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"},"IFirewall.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n// See LICENSE file for full license text.\n// Copyright (c) Ironblocks 2023\npragma solidity 0.8.19;\n\ninterface IFirewall {\n    function preExecution(address sender, bytes memory data, uint value) external;\n    function postExecution(address sender, bytes memory data, uint value) external;\n}\n"},"IFirewallConsumer.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n// See LICENSE file for full license text.\n// Copyright (c) Ironblocks 2023\npragma solidity 0.8.19;\n\ninterface IFirewallConsumer {\n    function firewallAdmin() external returns (address);\n}\n"},"ILockDealNFT.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./IProvider.sol\";\nimport \"./IERC721Enumerable.sol\";\nimport \"./IVaultManager.sol\";\n\ninterface ILockDealNFT is IERC721Enumerable {\n    function approvedContracts(address contractAddress) external view returns (bool);\n\n    function mintAndTransfer(\n        address owner,\n        address token,\n        uint256 amount,\n        IProvider provider\n    ) external returns (uint256 poolId);\n\n    function safeMintAndTransfer(\n        address owner,\n        address token,\n        address from,\n        uint256 amount,\n        IProvider provider,\n        bytes calldata data\n    ) external returns (uint256 poolId);\n\n    function cloneVaultId(uint256 destinationPoolId, uint256 sourcePoolId) external;\n\n    function mintForProvider(address owner, IProvider provider) external returns (uint256 poolId);\n\n    function getData(uint256 poolId) external view returns (BasePoolInfo memory poolInfo);\n\n    function getFullData(uint256 poolId) external view returns (BasePoolInfo[] memory poolInfo);\n\n    function tokenOf(uint256 poolId) external view returns (address token);\n\n    function vaultManager() external view returns (IVaultManager);\n\n    function poolIdToProvider(uint256 poolId) external view returns (IProvider provider);\n\n    function getWithdrawableAmount(uint256 poolId) external view returns (uint256 withdrawalAmount);\n\n    struct BasePoolInfo {\n        IProvider provider;\n        string name;\n        uint256 poolId;\n        uint256 vaultId;\n        address owner;\n        address token;\n        uint256[] params;\n    }\n}\n"},"IProvider.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n///@dev Interface for the provider contract\n///@notice This interface is used by the NFT contract to call the provider contract\ninterface IProvider {\n    event UpdateParams(uint256 indexed poolId, uint256[] params);\n\n    function withdraw(uint256 tokenId) external returns (uint256 withdrawnAmount, bool isFinal);\n\n    function split(uint256 oldPoolId, uint256 newPoolId, uint256 ratio) external;\n\n    function registerPool(uint256 poolId, uint256[] calldata params) external;\n\n    function getParams(uint256 poolId) external view returns (uint256[] memory params);\n\n    function getWithdrawableAmount(uint256 poolId) external view returns (uint256 withdrawalAmount);\n\n    function currentParamsTargetLength() external view returns (uint256);\n\n    function name() external view returns (string memory);\n\n    function getSubProvidersPoolIds(uint256 poolID) external view returns (uint256[] memory poolIds);\n}\n"},"ISimpleProvider.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./IProvider.sol\";\n\n///@dev Interface for the simple providers\ninterface ISimpleProvider is IProvider {\n    function withdraw(uint256 poolId, uint256 amount) external returns (uint256 withdrawnAmount, bool isFinal);\n}\n"},"IVaultManager.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./IERC2981.sol\";\n\ninterface IVaultManager is IERC2981 {\n    function depositByToken(address _tokenAddress, uint _amount) external returns (uint vaultId);\n    function safeDeposit(\n        address _tokenAddress,\n        uint _amount,\n        address _from,\n        bytes memory _signature\n    ) external returns (uint vaultId);\n    function withdrawByVaultId(uint _vaultId, address to, uint _amount) external;\n    function vaultIdToTokenAddress(uint _vaultId) external view returns (address token);\n    function vaultIdToTradeStartTime(uint256 _vaultId) external view returns (uint256 startTime);\n}\n"},"SimpleRefundBuilder.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./ERC721Holder.sol\";\nimport \"./ISimpleProvider.sol\";\nimport \"./BuilderInternal.sol\";\nimport \"./CalcUtils.sol\";\nimport \"./FirewallConsumer.sol\";\n\n/// @title SimpleRefundBuilder contract\n/// @notice Implements a contract for building refund simple providers\ncontract SimpleRefundBuilder is ERC721Holder, BuilderInternal, FirewallConsumer {\n    using CalcUtils for uint256;\n    IProvider public refundProvider;\n    IProvider public collateralProvider;\n\n    constructor(ILockDealNFT _nft, IProvider _refund, IProvider _collateral) {\n        lockDealNFT = _nft;\n        refundProvider = _refund;\n        collateralProvider = _collateral;\n    }\n\n    struct ParamsData {\n        ISimpleProvider provider;\n        address token;\n        address mainCoin;\n        uint256 mainCoinAmount;\n    }\n\n    struct MassPoolsLocals {\n        ParamsData paramsData;\n        uint256[] simpleParams;\n        uint256 totalAmount;\n        uint256 poolId;\n        uint256[] refundParams;\n    }\n\n    /// @param addressParams[0] = simpleProvider\n    /// @param addressParams[1] = token\n    /// @param addressParams[2] = mainCoin\n    /// @param userData - array of user pools\n    /// @param params[0] = collateral params, [0] start amount, [1] finish time\n    /// @param params[1] = Array of params for simpleProvider. May be empty if this is DealProvider\n    function buildMassPools(\n        address[] calldata addressParams,\n        Builder calldata userData,\n        uint256[][] calldata params,\n        bytes calldata tokenSignature,\n        bytes calldata mainCoinSignature\n    ) external firewallProtected {\n        MassPoolsLocals memory locals;\n        locals.paramsData = _validateParamsData(addressParams, params);\n        require(userData.userPools.length \u003e 0, \"invalid user length\");\n        locals.totalAmount = userData.totalAmount;\n        require(locals.totalAmount \u003e 0, \"invalid totalAmount\");\n        locals.simpleParams = _concatParams(userData.userPools[0].amount, params[1]);\n        locals.poolId = _createFirstNFT(\n            locals.paramsData.provider,\n            locals.paramsData.token,\n            userData.userPools[0].user,\n            locals.totalAmount,\n            locals.simpleParams,\n            tokenSignature\n        );\n        locals.refundParams = _finalizeFirstNFT(\n            locals.poolId,\n            locals.paramsData.mainCoin,\n            locals.totalAmount,\n            locals.paramsData.mainCoinAmount,\n            params[0][1],\n            mainCoinSignature\n        );\n        _userDataIterator(locals.paramsData.provider, userData.userPools, locals.totalAmount, locals.poolId, locals.simpleParams, locals.refundParams);\n    }\n\n    function _createFirstNFT(\n        ISimpleProvider provider,\n        address token,\n        address owner,\n        uint256 totalAmount,\n        uint256[] memory params,\n        bytes calldata signature\n    ) internal virtual override firewallProtectedSig(0x29454335) returns (uint256 poolId) {\n        // one time token transfer for deacrease number transactions\n        lockDealNFT.mintForProvider(owner, refundProvider);\n        poolId = super._createFirstNFT(provider, token, address(refundProvider), totalAmount, params, signature);\n    }\n\n    function _createCollateralProvider(\n        address mainCoin,\n        uint256 tokenPoolId,\n        uint256 totalAmount,\n        uint256 mainCoinAmount,\n        uint256 collateralFinishTime,\n        bytes calldata signature\n    ) internal firewallProtectedSig(0x4516d406) returns (uint256 poolId) {\n        poolId = lockDealNFT.safeMintAndTransfer(\n            msg.sender,\n            mainCoin,\n            msg.sender,\n            mainCoinAmount,\n            collateralProvider,\n            signature\n        );\n        uint256[] memory collateralParams = new uint256[](3);\n        collateralParams[0] = totalAmount;\n        collateralParams[1] = mainCoinAmount;\n        collateralParams[2] = collateralFinishTime;\n        collateralProvider.registerPool(poolId, collateralParams);\n        lockDealNFT.cloneVaultId(poolId + 2, tokenPoolId);\n    }\n\n    function _validateParamsData(\n        address[] calldata addressParams,\n        uint256[][] calldata params\n    ) internal view returns (ParamsData memory paramsData) {\n        require(addressParams.length == 3, \"invalid addressParams length\");\n        require(params.length == 2, \"invalid params length\");\n        require(\n            ERC165Checker.supportsInterface(addressParams[0], type(ISimpleProvider).interfaceId),\n            \"invalid provider type\"\n        );\n        require(addressParams[0] != address(0), \"invalid provider address\");\n        require(addressParams[1] != address(0), \"invalid token address\");\n        require(addressParams[2] != address(0), \"invalid mainCoin address\");\n        paramsData.token = addressParams[1];\n        paramsData.provider = ISimpleProvider(addressParams[0]);\n        paramsData.mainCoin = addressParams[2];\n        paramsData.mainCoinAmount = params[0][0];\n    }\n\n    function _finalizeFirstNFT(\n        uint256 tokenPoolId,\n        address mainCoin,\n        uint256 totalAmount,\n        uint256 mainCoinAmount,\n        uint256 collateralFinishTime,\n        bytes calldata signature\n    ) internal firewallProtectedSig(0xcfc2dc78) returns (uint256[] memory refundParams) {\n        refundParams = new uint256[](1);\n        refundParams[0] = _createCollateralProvider(\n            mainCoin,\n            tokenPoolId,\n            totalAmount,\n            mainCoinAmount,\n            collateralFinishTime,\n            signature\n        );\n        refundProvider.registerPool(tokenPoolId - 1, refundParams);\n    }\n\n    function _userDataIterator(\n        ISimpleProvider provider,\n        UserPool[] calldata userData,\n        uint256 totalAmount,\n        uint256 tokenPoolId,\n        uint256[] memory simpleParams,\n        uint256[] memory refundParams\n    ) internal firewallProtectedSig(0xbbc1f709) {\n        uint256 length = userData.length;\n        require(length \u003e 0, \"invalid userPools length\");\n        totalAmount -= userData[0].amount;\n        // create refund pools for users\n        for (uint256 i = 1; i \u003c length; ) {\n            uint256 userAmount = userData[i].amount;\n            address user = userData[i].user;\n            uint256 refundPoolId = lockDealNFT.mintForProvider(user, refundProvider);\n            totalAmount -= _createNewNFT(\n                provider,\n                tokenPoolId,\n                UserPool(address(refundProvider), userAmount),\n                simpleParams\n            );\n            refundProvider.registerPool(refundPoolId, refundParams);\n            unchecked {\n                ++i;\n            }\n        }\n        // check that all tokens are distributed correctly\n        assert(totalAmount == 0);\n    }\n}"}}