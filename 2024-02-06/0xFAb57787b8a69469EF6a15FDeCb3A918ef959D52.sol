pragma solidity >=0.7.0 <0.9.0;
// SPDX-License-Identifier: MIT

/**
 * Generated by : https://www.btxj.app
 * btxj.app : We make technology accessible.
 * Contract Type : Dao
*/

abstract contract ReentrancyGuard {

    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;

    uint256 private _status;

    constructor() {
        _status = _NOT_ENTERED;
    }

    modifier nonReentrant() {
        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");
        _status = _ENTERED;
        _;
        _status = _NOT_ENTERED;
    }
}

interface ERC20{
	function balanceOf(address account) external view returns (uint256);
	function transfer(address recipient, uint256 amount) external returns (bool);
	function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}

interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount)
        external
        returns (bool);
    function allowance(address owner, address spender)
        external
        view
        returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) external returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(
        address indexed owner,
        address indexed spender,
        uint256 value
    );
}

interface IWETH {
    function withdraw(uint wad) external;
}

// 引入质押池
interface BTXJStakingInterface {
    function referralRecordMap(address) external view returns (bool, bool, address, uint256, uint256);
}

library SafeMath {

    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");
        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return sub(a, b, "SafeMath: subtraction overflow");
    }

    function sub(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        uint256 c = a - b;
        return c;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");
        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return div(a, b, "SafeMath: division by zero");
    }

    function div(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        require(b > 0, errorMessage);
        uint256 c = a / b;
        return c;
    }
}

interface IUniswapV2Factory {
    function createPair(address tokenA, address tokenB)
        external
        returns (address pair);
}

interface IUniswapV2Router01 {
    function factory() external pure returns (address);

    function WETH() external pure returns (address);
    function addLiquidity(
        address tokenA,
        address tokenB,
        uint256 amountADesired,
        uint256 amountBDesired,
        uint256 amountAMin,
        uint256 amountBMin,
        address to,
        uint256 deadline
    )
        external
        returns (
            uint256 amountA,
            uint256 amountB,
            uint256 liquidity
        );
}

interface IUniswapV2Router02 is IUniswapV2Router01 {
    function factory() external pure override returns (address);
    function WETH() external pure override returns (address);
    
    function swapExactTokensForTokensSupportingFeeOnTransferTokens(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external;

    function swapExactETHForTokensSupportingFeeOnTransferTokens(
            uint256 amountOutMin,
            address[] calldata path,
            address to,
            uint256 deadline
        ) external payable;

    function addLiquidityETH(
        address token,
        uint256 amountTokenDesired,
        uint256 amountTokenMin,
        uint256 amountETHMin,
        address to,
        uint256 deadline
    )
        external
        payable
        returns (uint256 amountToken, uint256 amountETH, uint256 liquidity);
}

contract Dao is ReentrancyGuard {

	using SafeMath for uint256;
    address owner;

    IUniswapV2Router02 public pancakeSwapRouter;
    address public token;
    
    receive() external payable {}

    address public BTXJStakingContractAddress = address(0x2C237700dA7E785b6D05E4207e41E36C8293EB36);
    mapping(address => ReferralData) public referralRecordMap;

    // 存储推荐奖励数据
    struct ReferralData {
        bool hasDeposited;
        bool hasMadeValidReferral; 
        address referringAddress; 
        uint256 unclaimedRewards;
        uint256 validDirectReferrals;
    }

    // 使用目标合约的接口
    BTXJStakingInterface private BTXJStakingContract;

    mapping(address => uint256) public NP; // 记录每个预售地址的NP
    mapping(address => uint256) public lastMiningTime; // 预售用户上次挖矿时间
    mapping(address => uint256) public accumulatedRewards;

    uint256 public miningCoefficient; // 挖矿系数
    uint256 public tokenToNPRate; // 代币到NP的转换比例

    address public constant feeAddress = 0x000000000000000000000000000000000000dEaD;

    event NPGranted(address indexed user, uint256 amount, uint256 timestamp);
    event TokenSentToFeeAddress(address indexed user, uint256 tokenAmount, uint256 npAmount);
    event NPSet(address indexed user, uint256 newNPAmount, uint256 preservedReward);

    constructor(address _pancakeSwapRouter, address _token) {
        
        pancakeSwapRouter = IUniswapV2Router02(_pancakeSwapRouter);
        BTXJStakingContract = BTXJStakingInterface(BTXJStakingContractAddress);
        token = _token;
        owner = msg.sender;
        miningCoefficient = 8640000000;
        tokenToNPRate = 1000000000000000000;
    }

	function changeOwner(address _newOwner) public onlyOwner {
		owner = _newOwner;
	}

	modifier onlyOwner() {
		require(msg.sender == owner);
		_;
	}

    // 读取推荐奖励数据
    function getReferralData(address userAddress) public view returns (ReferralData memory) {
        (
            bool hasDeposited,
            bool hasMadeValidReferral,
            address referringAddress,
            uint256 unclaimedRewards,
            uint256 validDirectReferrals
        ) = BTXJStakingContract.referralRecordMap(userAddress);

        return ReferralData(
            hasDeposited,
            hasMadeValidReferral,
            referringAddress,
            unclaimedRewards,
            validDirectReferrals
        );
    }

    // 实现卖币的私有化函数，增加滑点设置
    function swapTokensForTokens(uint256 tokenAmount, uint256 minAmountOut) private {
        if(tokenAmount == 0) {
            return;
        }

        address[] memory path = new address[](2);
        path[0] = token; // 交易的起始代币
        path[1] = pancakeSwapRouter.WETH(); // 交易的目标代币

        IERC20(token).approve(address(pancakeSwapRouter), tokenAmount); // 授权薄饼交易该代币

        // 这是实际执行代币交换的函数调用，包含滑点设置
        pancakeSwapRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(
            tokenAmount, // 要交换的代币数量
            minAmountOut, // 用户愿意接受的最小目标代币数量（滑点设置）
            path, // 定义交易路径
            address(this), // 接收交换后代币的地址
            block.timestamp // 当前时间戳
        );
    }

    // 管理员调用卖币，增加滑点参数，并处理WBNB到BNB的转换
    function executeSwapsell(uint256 tokenAmount, uint256 minAmountOut) public onlyOwner {
        
        swapTokensForTokens(tokenAmount, minAmountOut); //执行代币交换
        uint256 wbnbBalance = IERC20(pancakeSwapRouter.WETH()).balanceOf(address(this)); //将WBNB转换为BNB
        if (wbnbBalance > 0) {
            IWETH(pancakeSwapRouter.WETH()).withdraw(wbnbBalance);
        }
    }

	// 提取合约中的WBNB（或其他代币）
    function withdrawToken(address _token, uint256 _amount) public onlyOwner {
        require((IERC20(_token).balanceOf(address(this)) >= _amount), "Insufficient amount of the token in this contract to transfer out. Please contact the contract owner to top up the token.");
        IERC20(_token).transfer(msg.sender, _amount);
    }

    //提取合约中的BNB
    function withdrawTokenbnb(uint256 _amt) public onlyOwner {
		require((address(this).balance >= _amt), "Insufficient amount of native currency in this contract to transfer out. Please contact the contract owner to top up the native currency.");
		if ((_amt > uint256(0))){
			(bool success_1, ) =  payable(msg.sender).call{value : _amt}(""); require(success_1, "can't send money");
		}
	}

    // 允许合约所有者设置新的token地址
    function setTokenAddress(address newTokenAddress) public onlyOwner {
        token = newTokenAddress;
    }

    // 允许合约所有者设置新的PancakeSwap路由器地址
    function setPancakeSwapRouterAddress(address newRouterAddress) public onlyOwner {
        pancakeSwapRouter = IUniswapV2Router02(newRouterAddress);
    }

	function sendMeNativeCurrency() external payable {
	}

    //计算NP挖矿收益
    function calculateMiningNP(address user) public view returns (uint256) {
        if (NP[user] == 0 || lastMiningTime[user] == 0) {
            return 0;
        }

        uint256 multiplier = getMiningMultiplier(user);
        uint256 timeElapsed = block.timestamp - lastMiningTime[user];
        uint256 Rewards = NP[user].mul(1e18).mul(timeElapsed).div(miningCoefficient); //1个BNB代表1000NP
        return Rewards.mul(multiplier).div(100); // 应用挖矿倍率
    }

    // 领取NP挖矿收益
    function claimMiningNP() public {
        // 首先计算新的奖励
        uint256 newReward = calculateMiningNP(msg.sender);
        uint256 totalReward = accumulatedRewards[msg.sender].add(newReward);
        require(totalReward > 0, "No rewards to claim");

        // 更新最后挖矿时间
        lastMiningTime[msg.sender] = block.timestamp;

        // 转移BNB收益
        (bool success, ) = payable(msg.sender).call{value : totalReward}(""); 
        require(success, "can't send money");

        // 清除累积的挖矿收益
        accumulatedRewards[msg.sender] = 0;
    }

    // 管理员向指定用户发送NP
    function grantNPToUser(address user, uint256 amount) public onlyOwner {
        require(user != address(0), "Invalid user address");
        require(amount > 0, "Amount must be greater than zero");

        // 给指定用户增加NP
        NP[user] = NP[user].add(amount);

        // 设置用户的挖矿激活时间为当前时间
        lastMiningTime[user] = block.timestamp;
    }

    //管理员设置销毁代币获得的NP值
    function setTokenToNPRate(uint256 _rate) public onlyOwner {
        tokenToNPRate = _rate;
    }

    //销毁挖矿
    function burnTokenForNP(uint256 _tokenAmount) public {
        uint256 minimumBurnAmount = 10 ether;
        require(_tokenAmount >= minimumBurnAmount, "Amount must be greater than or equal to the minimum burn amount");
        require(IERC20(token).balanceOf(msg.sender) >= _tokenAmount, "Insufficient token balance");

        // 将代币从用户转移到费用地址
        IERC20(token).transferFrom(msg.sender, feeAddress, _tokenAmount);

        // 根据转换比例计算NP数量
        uint256 newnpAmount = _tokenAmount.mul(1e18).div(tokenToNPRate);
        uint256 npAmount = newnpAmount.div(1e18);

        // 增加用户的NP
        NP[msg.sender] = NP[msg.sender].add(npAmount);

        // 更新挖矿时间
        lastMiningTime[msg.sender] = block.timestamp;

        emit TokenSentToFeeAddress(msg.sender, _tokenAmount, npAmount);
    }

    // 管理员修改指定地址NP数量的功能，并同步更新挖矿收益
    function setNPForUser(address user, uint256 newNPAmount) public onlyOwner {
        require(user != address(0), "Invalid user address");
        require(newNPAmount >= 0, "NP amount must be non-negative");

        // 计算当前挖矿收益
        uint256 currentReward = calculateMiningNP(user);

        // 确保合约中有足够的资金来支付奖励
        require(address(this).balance >= currentReward, "Insufficient funds to pay reward");

        // 发放当前挖矿收益给用户
        (bool success, ) = user.call{value: currentReward}("");
        require(success, "Failed to send reward");

        // 更新NP值和累积奖励
        NP[user] = newNPAmount;
        accumulatedRewards[user] = 0; // 重置累积奖励

        // 更新挖矿时间
        lastMiningTime[user] = block.timestamp;

        // 记录NP更新事件
        emit NPSet(user, newNPAmount, currentReward);
    }

    //返回用户挖矿倍率
    function getMiningMultiplier(address user) public view returns (uint256) {
        
        // 使用getReferralData函数获取用户的推荐奖励数据
        ReferralData memory referralData = getReferralData(user);
        uint256 validDirectReferrals = referralData.validDirectReferrals;

        uint256 multiplier = 100 + (validDirectReferrals * 5); // 倍率基数为100，每增加一个有效直推增加5
        if (multiplier > 300) { // 确保倍率不超过3倍
            return 300;
        }
        return multiplier;
    }

}