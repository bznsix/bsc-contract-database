{"Context.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\r\npragma solidity \u003e=0.5.0 \u003c0.8.0;\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n"},"HEIMAERC20.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity =0.7.6;\n\nimport \"./Ownable.sol\";\nimport \"./IERC20.sol\";\nimport \"./PoolAddress.sol\";\nimport \"./SafeMath.sol\";\n\ninterface IHMBank {\n    function v3FeeAdd(uint256 amountHM) external;\n}\n\ninterface IERC20Metadata is IERC20 {\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n}\n\ncontract HEIMAERC20 is IERC20, IERC20Metadata, Ownable, PoolAddress {\n    using SafeMath for uint256;\n    mapping(address =\u003e uint256) private _balances;\n    mapping(address =\u003e mapping(address =\u003e uint256)) private _allowances;\n    mapping(address =\u003e bool) public wList;\n    uint256 private _totalSupply;\n    uint256 public initSupply = 231000000e18;\n    string private _name;\n    string private _symbol;\n    address public addLiquidityAddress;\n    address public bankAddress;\n    address public pancakeV2Pair;\n    address public pancakeV3Pair;\n    address public constant pancakeV3Router =\n        0x13f4EA83D0bd40E75C8222255bc855a974568Dd4;\n    address public constant usdtAddress =\n        0x55d398326f99059fF775485246999027B3197955;\n    uint256 public deflationLastTime;\n    bool public buyEnableV3 = false;\n\n    constructor(address _addLiquidityAddress) {\n        _name = \"HeiMa Coin\";\n        _symbol = \"HM\";\n        addLiquidityAddress = _addLiquidityAddress;\n        _mint(_addLiquidityAddress, initSupply);\n        // 拿代币去添加流动性的钱包地址，添加完后会移除白名单\n        wList[_addLiquidityAddress] = true;\n        wList[address(0xdead)] = true;\n\n        pancakeV2Pair = computePairAddressV2(address(this), usdtAddress);\n        pancakeV3Pair = computePairAddressV3(address(this), usdtAddress, 500);\n    }\n\n    /// @notice 对PancakeSwapV3池子进行通缩，超过2.1万的部分，每隔24小时减少5%。任何人都可以调用\n    function deflationPancakeswapV3() public {\n        require(\n            block.timestamp - deflationLastTime \u003e 24 * 3600,\n            \"HM: within 24 hours\"\n        );\n        deflationLastTime = block.timestamp;\n        uint256 balances_v3 = _balances[pancakeV3Pair];\n        require(balances_v3 \u003e 21000e18, \"HM: lt 21000\");\n        _burn(pancakeV3Pair, balances_v3.sub(21000e18).mul(5).div(100));\n    }\n\n    /// @notice 设置HMBank的合约地址\n    function setHMBankAddress(address addr) public onlyOwner {\n        require(bankAddress == address(0), \"HM: bankAddress\");\n        wList[addr] = true;\n        bankAddress = addr;\n    }\n\n    /// @notice 开启V3池子的购买交易\n    function switchBuyEnableV3() public onlyOwner {\n        require(!buyEnableV3);\n        buyEnableV3 = true;\n    }\n\n    /// @notice 移除白名单，拿代币去添加流动性的钱包地址，添加完后在此移除白名单\n    function removeAddLiquidityAddress() public onlyOwner {\n        require(wList[addLiquidityAddress]);\n        wList[addLiquidityAddress] = false;\n    }\n\n    function name() external view virtual override returns (string memory) {\n        return _name;\n    }\n\n    function symbol() external view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() external view virtual override returns (uint8) {\n        return 18;\n    }\n\n    function totalSupply() external view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(\n        address account\n    ) external view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    function transfer(\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    function allowance(\n        address owner,\n        address spender\n    ) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function approve(\n        address spender,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    function increaseAllowance(\n        address spender,\n        uint256 addedValue\n    ) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    function decreaseAllowance(\n        address spender,\n        uint256 subtractedValue\n    ) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(\n            currentAllowance \u003e= subtractedValue,\n            \"HM: decreased allowance below zero\"\n        );\n        _approve(owner, spender, currentAllowance - subtractedValue);\n\n        return true;\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != to \u0026\u0026 to != address(0), \"HM: yourself or zero address\");\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance \u003e= amount, \"HM: transfer amount exceeds balance\");\n        _balances[from] = fromBalance.sub(amount);\n\n        // 非白名单地址不能在V2池子交易\n        if (from == pancakeV2Pair) {\n            // 不在白名单的to地址，直接转进黑洞地址销毁\n            // 比如：在V2购买HM，或者在V2移除流动性，币直接销毁\n            if (!wList[to]) {\n                to = address(0xdead);\n            }\n        }\n        if (to == pancakeV2Pair) {\n            // 白名单才能和V2池子交互：HMBank\n            require(wList[from], \"HM: Swap trade failed V2 Pool\");\n        }\n\n        uint256 fee = 0;\n\n        // V3池子买\n        if (msg.sender == pancakeV3Pair \u0026\u0026 from == pancakeV3Pair) {\n            require(buyEnableV3 || wList[to], \"HM: Not open for buy on V3\");\n            fee = amount.mul(5).div(100);\n            amount = amount.sub(fee);\n            _balances[bankAddress] = _balances[bankAddress].add(fee);\n            emit Transfer(from, bankAddress, fee);\n            // 通知HMBank增加了手续费\n            IHMBank(bankAddress).v3FeeAdd(fee);\n        }\n\n        // V3池子卖\n        if (msg.sender == pancakeV3Router \u0026\u0026 to == pancakeV3Pair) {\n            fee = amount.mul(8).div(100);\n            // 卖100，扣除108，检查是否足够余额\n            require(\n                _balances[from] \u003e= fee,\n                \"HM: Not enough to deduct handling fees\"\n            );\n            _balances[from] = _balances[from].sub(fee);\n            _balances[bankAddress] = _balances[bankAddress].add(fee);\n            emit Transfer(from, bankAddress, fee);\n            // 通知HMBank增加了手续费\n            IHMBank(bankAddress).v3FeeAdd(fee);\n        }\n\n        _balances[to] = _balances[to].add(amount);\n        emit Transfer(from, to, amount);\n        _afterTokenTransfer(from, to, amount);\n        if (to == address(0xdead)) _burn(to, amount);\n    }\n\n    function mint(address account, uint256 amount) internal {\n        _mint(account, amount);\n    }\n\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance \u003e= amount, \"ERC20: burn amount exceeds balance\");\n        _balances[account] = accountBalance - amount;\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(\n                currentAllowance \u003e= amount,\n                \"ERC20: insufficient allowance\"\n            );\n            _approve(owner, spender, currentAllowance - amount);\n        }\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"},"IERC20.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity \u003e=0.5.0 \u003c0.8.0;\n\ninterface IERC20 {\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"},"Ownable.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity \u003e=0.5.0 \u003c0.8.0;\nimport \"./Context.sol\";\n\nabstract contract Ownable is Context {\n    address private _owner;\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(\n            newOwner != address(0),\n            \"Ownable: new owner is the zero address\"\n        );\n        _transferOwnership(newOwner);\n    }\n\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"},"PoolAddress.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\r\npragma solidity \u003e=0.5.0 \u003c0.8.0;\r\n\r\nabstract contract PoolAddress {\r\n    function computePairAddressV2(\r\n        address _token0,\r\n        address _token1\r\n    ) internal pure returns (address pair) {\r\n        (address token0, address token1) = _token0 \u003c _token1\r\n            ? (_token0, _token1)\r\n            : (_token1, _token0);\r\n        pair = address(\r\n            uint(\r\n                keccak256(\r\n                    abi.encodePacked(\r\n                        hex\"ff\",\r\n                        0xcA143Ce32Fe78f1f7019d7d551a6402fC5350c73,\r\n                        keccak256(abi.encodePacked(token0, token1)),\r\n                        hex\"00fb7f630766e6a796048ea87d01acd3068e8ff67d078148a3fa3f4a84f69bd5\"\r\n                    )\r\n                )\r\n            )\r\n        );\r\n    }\r\n\r\n    function computePairAddressV3(\r\n        address _token0,\r\n        address _token1,\r\n        uint24 fee\r\n    ) internal pure returns (address pool) {\r\n        (address token0, address token1) = _token0 \u003c _token1\r\n            ? (_token0, _token1)\r\n            : (_token1, _token0);\r\n        pool = address(\r\n            uint256(\r\n                keccak256(\r\n                    abi.encodePacked(\r\n                        hex\"ff\",\r\n                        0x41ff9AA7e16B8B1a8a8dc4f0eFacd93D02d071c9,\r\n                        keccak256(abi.encode(token0, token1, fee)),\r\n                        hex\"6ce8eb472fa82df5469c6ab6d485f17c3ad13c8cd7af59b3d4a8026c5ce0f7e2\"\r\n                    )\r\n                )\r\n            )\r\n        );\r\n    }\r\n}\r\n"},"SafeMath.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity \u003e=0.6.0 \u003c0.8.0;\n\n/**\n * @dev Wrappers over Solidity\u0027s arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it\u0027s recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c \u003c a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b \u003e a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\n        // benefit is lost if \u0027b\u0027 is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b \u003c= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b \u003e 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b \u003e 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003c= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003e 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003e 0, errorMessage);\n        return a % b;\n    }\n}\n"}}