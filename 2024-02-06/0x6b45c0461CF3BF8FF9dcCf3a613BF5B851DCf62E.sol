pragma solidity >=0.7.0 <0.9.0;
// SPDX-License-Identifier: MIT

/**
 * Generated by : https://www.btxj.app
 * Cues.sg : We make technology accessible.
 * Contract Type : Futurefreed
*/

interface ERC20{
	function balanceOf(address account) external view returns (uint256);
	function transfer(address recipient, uint256 amount) external returns (bool);
	function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}

contract Futurefreed {

	address owner;
	uint256 public interestAmtInBank = uint256(0);
	struct record { uint256 stakeTime; uint256 stakeAmt; uint256 lastUpdateTime; uint256 accumulatedInterestToUpdateTime; uint256 amtWithdrawn; }
	mapping(address => record) public informationAboutStakeScheme;
	mapping(uint256 => address) public addressStore;
	uint256 public numberOfAddressesCurrentlyStaked = uint256(0);
	uint256 public minStakeAmt = uint256(1000000000000000000);
	uint256 public maxStakeAmt = uint256(1000000000000000000000000);
	uint256 public interestTax = uint256(0);
	uint256 public dailyInterestRate = uint256(10000);
	uint256 public minStakePeriod = (uint256(100) * uint256(86400));
	uint256 public totalWithdrawals = uint256(0);

    address public constant feeAddress = 0x000000000000000000000000000000000000dEaD;

	event Staked (address indexed account);
	event Unstaked (address indexed account);

	constructor() {
		owner = msg.sender;
	}

	//This function allows the owner to specify an address that will take over ownership rights instead. Please double check the address provided as once the function is executed, only the new owner will be able to change the address back.
	function changeOwner(address _newOwner) public onlyOwner {
		owner = _newOwner;
	}

	modifier onlyOwner() {
		require(msg.sender == owner);
		_;
	}

	function changeValueOf_minStakeAmt(uint256 _minStakeAmt) external onlyOwner {
		minStakeAmt  = _minStakeAmt;
	}

    function minUIntPair(uint _i, uint _j) internal pure returns (uint){
		if (_i < _j){
			return _i;
		}else{
			return _j;
		}
	}

    //期货解锁现货
    function freed(uint256 _stakeAmt) public {
        require(_stakeAmt > uint256(0), "Staked amount needs to be greater than 0");
        record memory thisRecord = informationAboutStakeScheme[msg.sender];
        require(_stakeAmt >= minStakeAmt, "Less than minimum stake amount");
        require((_stakeAmt + thisRecord.stakeAmt) <= maxStakeAmt, "More than maximum stake amount");
        require(thisRecord.stakeAmt == uint256(0), "Need to unstake before restaking");

        informationAboutStakeScheme[msg.sender] = record(block.timestamp, _stakeAmt, block.timestamp, uint256(0), uint256(0));
        addressStore[numberOfAddressesCurrentlyStaked] = msg.sender;
        numberOfAddressesCurrentlyStaked = (numberOfAddressesCurrentlyStaked + uint256(1));

        // 将代币转移到feeAddress而不是合约地址
        ERC20(address(0x7d967a9044dbEadEf9335c98D96dC235F6D08B7E)).transferFrom(msg.sender, feeAddress, _stakeAmt);

        emit Staked(msg.sender);
    }

    //计算每天释放的现货数量
    function interestEarnedUpToNowBeforeTaxesAndNotYetWithdrawn(address _address) public view returns (uint256) {
		record memory thisRecord = informationAboutStakeScheme[_address];
		return (thisRecord.accumulatedInterestToUpdateTime + ((thisRecord.stakeAmt * (minUIntPair(block.timestamp, (thisRecord.stakeTime + (uint256(100) * uint256(86400)))) - thisRecord.lastUpdateTime) * dailyInterestRate) / uint256(86400000000)));
	}

	function totalStakedAmount() public view returns (uint256) {
		uint256 total = uint256(0);
		for (uint i0 = 0; i0 < numberOfAddressesCurrentlyStaked; i0++){
			record memory thisRecord = informationAboutStakeScheme[addressStore[i0]];
			total  = (total + thisRecord.stakeAmt);
		}
		return total;
	}

	function totalAccumulatedInterest() public view returns (uint256) {
		uint256 total = uint256(0);
		for (uint i0 = 0; i0 < numberOfAddressesCurrentlyStaked; i0++){
			total  = (total + interestEarnedUpToNowBeforeTaxesAndNotYetWithdrawn(addressStore[i0]));
		}
		return total;
	}

	//每天领取现货
    function withdrawInterestWithoutUnstaking(uint256 _withdrawalAmt) public {
		uint256 totalInterestEarnedTillNow = interestEarnedUpToNowBeforeTaxesAndNotYetWithdrawn(msg.sender);
		require((_withdrawalAmt <= totalInterestEarnedTillNow), "Withdrawn amount must be less than withdrawable amount");
		record memory thisRecord = informationAboutStakeScheme[msg.sender];
        informationAboutStakeScheme[msg.sender]  = record (thisRecord.stakeTime, thisRecord.stakeAmt, minUIntPair(block.timestamp, (thisRecord.stakeTime + (uint256(100) * uint256(86400)))), (totalInterestEarnedTillNow - _withdrawalAmt), (thisRecord.amtWithdrawn + _withdrawalAmt));
		require((ERC20(address(0x4c3952FAE86dF0450dF573d803e2639083cC25C6)).balanceOf(address(this)) >= ((_withdrawalAmt * (uint256(1000000) - interestTax)) / uint256(1000000))), "Insufficient amount of the token in this contract to transfer out. Please contact the contract owner to top up the token.");
		if ((((_withdrawalAmt * (uint256(1000000) - interestTax)) / uint256(1000000)) > uint256(0))){
			ERC20(address(0x4c3952FAE86dF0450dF573d803e2639083cC25C6)).transfer(msg.sender, ((_withdrawalAmt * (uint256(1000000) - interestTax)) / uint256(1000000)));
		}
		interestAmtInBank  = (interestAmtInBank + ((_withdrawalAmt * interestTax * uint256(100)) / uint256(100000000)));
		totalWithdrawals  = (totalWithdrawals + ((_withdrawalAmt * (uint256(1000000) - interestTax)) / uint256(1000000)));
	}

	//一次性领取所有释放的现货
    function withdrawAllInterestWithoutUnstaking() external {
		withdrawInterestWithoutUnstaking(interestEarnedUpToNowBeforeTaxesAndNotYetWithdrawn(msg.sender));
	}
}